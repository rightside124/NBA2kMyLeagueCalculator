<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MyCareer Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* Global styles and dark/light mode variables */
    :root {
      --bg: #0f172a;
      --text: #e2e8f0;
      --accent: #38bdf8;
      --section: #1e293b;
      --highlight: #fbbf24;
      --success: #22c55e;
      --danger: #ef4444;
    }
    body.light-mode {
      --bg: #f8fafc;
      --text: #1e293b;
      --accent: #0ea5e9;
      --section: #e2e8f0;
      --highlight: #ca8a04;
      --success: #16a34a;
      --danger: #dc2626;
    }
    
    html, body {
      min-height: 100vh; /* Ensure the document is at least viewport height */
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background-color: transparent; /* Make body transparent to show #space-bg */
      color: var(--text);
      transition: all 0.3s ease;
      overflow-x: hidden; /* Prevent horizontal scrolling on body, allow vertical */
    }
    h1, h2, h3 {
      color: var(--accent);
      margin-bottom: 10px;
    }
    .menu, .app-section {
      display: none; /* Hidden by default */
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      /* Ensure they take full height when active, but don't occupy space when hidden */
      position: fixed; /* Use fixed positioning for overlays to avoid layout shifts */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      padding: 20px;
      overflow-y: auto;
      z-index: 10; /* Ensure they are on top of background */
    }

    /* Specific styling for the main menu when active */
    .menu.active {
        display: flex; /* Use flex for centering content in the menu */
        opacity: 1;
        transform: translateY(0);
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: var(--section); /* Ensure menu background is distinct */
        border-radius: 0; /* Remove border-radius if it's full screen */
        box-shadow: none; /* Remove shadow if it's full screen */
        z-index: 20; /* Ensure menu is on top of app sections */
    }

    /* Styling for active app sections */
    .app-section.active {
      display: block; /* Block for app content */
      opacity: 1;
      transform: translateY(0);
      background: var(--section); /* Ensure app section has a background */
      z-index: 15; /* App sections are below menu but above background */
    }

    .app-container {
      animation: fadeIn 0.5s ease-in-out;
      display: flex;
      flex-direction: row;
      gap: 20px;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    button, .file-label {
      background: var(--accent);
      color: black;
      padding: 10px 20px;
      margin: 10px 5px;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    button:hover, .file-label:hover {
      background: var(--highlight);
    }
    button:active, .file-label:active {
        transform: scale(0.98);
    }
    button.success { background-color: var(--success); }
    button.success:hover { background-color: #16a34a; }
    button.danger { background-color: var(--danger); }
    button.danger:hover { background-color: #dc2626; }

    #fileInput, .file-input { display: none; }
    #space-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: -1; /* Keep it as background layer */
      background: radial-gradient(circle at center, #1e293b, #0f172a); /* This is the space background */
      overflow: hidden;
    }
    .particle {
      position: absolute;
      width: 2px; height: 2px;
      background: white;
      border-radius: 50%;
      animation: moveParticles linear infinite;
    }
    @keyframes moveParticles {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(100vh); opacity: 0; }
    }
    .panel {
      flex: 1 1 300px;
      background: var(--section);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      min-width: 300px;
    }
    label { display: block; margin-top: 10px; }
    input[type="number"], select {
      padding: 8px; margin-top: 5px; width: 100%;
      border-radius: 5px; border: none; font-size: 16px;
      box-sizing: border-box; background: var(--bg); color: var(--text);
    }
    .result {
      font-weight: bold; font-size: 18px;
      color: var(--highlight); margin-top: 10px;
    }
    .top-bar {
      display: flex; justify-content: space-between;
      align-items: center; margin-bottom: 20px; flex-wrap: wrap;
    }
    .top-bar button, .top-bar .file-label { /* Apply margin to buttons and labels in top-bar */
      margin: 5px 5px; /* Adjust margin for better spacing */
    }

    /* Slider Checkbox Styles */
    .checkbox-container {
      display: flex; /* Use flex to align label text and switch */
      align-items: center;
      position: relative;
      cursor: pointer;
      font-size: 1em;
      user-select: none;
      font-weight: normal;
      color: var(--text);
      margin-bottom: 5px; /* Reduced margin */
    }

    /* Hide default HTML checkbox and remove native appearance */
    .checkbox-container input[type="checkbox"] { /* CORRECTED SELECTOR */
      display: none !important; /* Force hide the actual checkbox */
      -webkit-appearance: none !important; /* For Safari/Chrome (fallback) */
      -moz-appearance: none !important;    /* For Firefox (fallback) */
      appearance: none !important;         /* Standard property (fallback) */
    }

    /* The switch - the box around the slider */
    .switch {
      position: relative;
      display: inline-block;
      width: 30px; /* Reduced width of the switch track */
      height: 16px; /* Reduced height of the switch track */
      margin-right: 10px; /* Space between switch and label text */
      flex-shrink: 0; /* Prevent switch from shrinking */
    }

    /* The slider (track) */
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--bg); /* Off state background */
      -webkit-transition: .4s;
      transition: .4s;
      border-radius: 20px; /* Rounded corners for the track */
      border: 1px solid var(--accent); /* Border for visibility */
    }

    /* The slider (circle/thumb) */
    .slider:before {
      position: absolute;
      content: "";
      height: 12px; /* Reduced size of the toggle circle */
      width: 12px; /* Reduced size of the toggle circle */
      left: 2px; /* Adjusted position of the toggle circle */
      bottom: 2px; /* Adjusted position of the toggle circle */
      background-color: white;
      -webkit-transition: .4s;
      transition: .4s;
      border-radius: 50%; /* Make it round */
    }

    /* When checkbox is checked */
    .switch input:checked + .slider { /* This selector is now effectively useless as input is hidden */
      background-color: var(--accent); /* On state background */
      border-color: var(--accent);
    }
    /* Corrected checked state for slider */
    .checkbox-container input[type="checkbox"]:checked + .switch .slider {
      background-color: var(--accent); /* On state background */
      border-color: var(--accent);
    }


    /* Focus effect */
    .switch input:focus + .slider { /* This selector is now effectively useless as input is hidden */
      box-shadow: 0 0 1px var(--accent);
    }
    /* Corrected focus effect for slider */
    .checkbox-container input[type="checkbox"]:focus + .switch .slider {
      box-shadow: 0 0 1px var(--accent);
    }

    /* Move slider thumb when checked */
    .switch input:checked + .slider:before { /* This selector is now effectively useless as input is hidden */
      -webkit-transform: translateX(12px); /* Adjusted move toggle to the right */
      -ms-transform: translateX(12px);
      transform: translateX(12px);
    }
    /* Corrected move slider thumb when checked */
    .checkbox-container input[type="checkbox"]:checked + .switch .slider:before {
      -webkit-transform: translateX(12px); /* Adjusted move toggle to the right */
      -ms-transform: translateX(12px);
      transform: translateX(12px);
    }


    @media (max-width: 768px) {
      .app-container, .top-bar { flex-direction: column; }
      .top-bar { align-items: flex-start; }
      .top-bar > div { margin-top: 10px; }
      button, .file-label { width: 100%; margin: 5px 0; }
      pre { font-size: 0.8rem; white-space: pre-wrap; word-wrap: break-word; }
    }
    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: var(--accent);
      border-radius: 50%; width: 24px; height: 24px;
      animation: spin 1s linear infinite; display: inline-block; vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* New message display styles */
    #messageDisplay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--section);
      color: var(--text);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      z-index: 1000;
      display: none; /* Hidden by default */
      max-width: 90%;
      text-align: center;
      transition: opacity 0.3s ease-in-out;
      opacity: 0;
      overflow-y: auto; /* For long reports */
      max-height: 80vh; /* Limit height for reports */
    }
    #messageDisplay.show {
      display: block;
      opacity: 1;
    }
    #messageDisplay button {
      margin-top: 10px;
      background: var(--accent);
      color: black;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
    }
    #messageDisplay button:hover {
      background: var(--highlight);
    }
    #messageDisplay pre {
        background: var(--bg);
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        text-align: left;
        white-space: pre-wrap; /* Ensures long lines wrap */
        word-wrap: break-word; /* Breaks words if necessary */
    }

    /* Main Menu Specific Styles */
    .menu {
      /* min-height: 80vh; Removed due to fixed positioning */
      background: var(--section); /* Added for better contrast */
      border-radius: 0; /* Removed border-radius if it's full screen */
      box-shadow: none; /* Removed shadow if it's full screen */
    }
    .menu h1 {
      font-size: 2.5em;
      margin-bottom: 30px;
      text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    }
    .menu button, .menu .file-label {
      width: 80%; /* Make buttons wider */
      max-width: 300px;
      margin: 10px 0;
      font-size: 1.1em;
      box-shadow: 3px 3px 8px rgba(0,0,0,0.3);
    }

    /* Bottom Bar for less used buttons */
    .bottom-bar {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 20px;
        padding-top: 10px;
        border-top: 1px solid var(--bg);
    }
    .bottom-bar button {
        margin: 5px 10px;
    }

    /* Individual attribute input styling for BBGM */
    .bbgm-attribute-group {
        border: 1px solid var(--bg);
        padding: 10px;
        border-radius: 8px;
        margin-bottom: 15px;
        background-color: var(--bg);
    }
    .bbgm-attribute-group h3 { /* For category titles */
        margin-top: 0;
        margin-bottom: 10px;
    }
    .bbgm-attribute-group label {
        margin-top: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.95em;
    }
    .bbgm-attribute-group input[type="text"], /* Changed to text */
    .bbgm-attribute-group select { /* Apply outline to select too */
      padding: 8px;
      margin-top: 5px;
      width: 45%; /* Adjust width for side-by-side labels */
      border-radius: 5px;
      border: 1px solid var(--accent); /* Added outline */
      font-size: 16px;
      box-sizing: border-box;
      background: var(--section); /* Use section background for inputs */
      color: var(--text);
      outline: none; /* Remove default outline */
    }
    .bbgm-attribute-group input[type="text"]:focus, /* Changed to text */
    .bbgm-attribute-group select:focus {
        border-color: var(--highlight); /* Highlight on focus */
        box-shadow: 0 0 5px var(--highlight);
    }
    /* Specific style for read-only inputs */
    .bbgm-attribute-group input[type="text"][readonly] {
        background-color: var(--bg); /* Differentiate read-only visually */
        border-color: var(--bg);
        cursor: default;
    }

    .bbgm-attribute-group label span { /* For Current/Target labels within the flex */
        /* Removed min-width to allow more flexible spacing */
    }
    .bbgm-attribute-group .result {
        text-align: right;
        margin-top: 5px;
        font-size: 1em;
    }

    /* Styles for the consolidated Season Statistics Panel */
    .season-stats-tabs {
        display: flex;
        margin-bottom: 10px;
    }
    .season-stats-tabs button {
        flex: 1;
        padding: 10px;
        background-color: var(--bg);
        color: var(--text);
        border: 1px solid var(--accent);
        border-radius: 5px 5px 0 0;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s ease, color 0.2s ease;
        margin: 0 2px; /* Small margin between buttons */
    }
    .season-stats-tabs button:first-child {
        margin-left: 0;
    }
    .season-stats-tabs button:last-child {
        margin-right: 0;
    }
    .season-stats-tabs button.active {
        background-color: var(--accent);
        color: black;
        border-bottom-color: var(--accent); /* Keep border on active tab */
    }
    .season-stats-content {
        border: 1px solid var(--bg);
        border-top: none; /* Remove top border as tabs provide it */
        padding: 10px;
        border-radius: 0 0 8px 8px;
        background-color: var(--bg);
        min-height: 150px; /* Ensure some height even if no stats */
    }
  </style>
</head>
<body>
  <div id="space-bg"></div>

  <!-- Message Display Area -->
  <div id="messageDisplay">
    <div id="messageContent"></div>
    <button onclick="hideMessage()">Close</button>
  </div>

  <!-- Main Menu -->
  <div class="menu active" id="mainMenu">
    <h1>🏀 MyCareer Simulators</h1>
    <label for="fileInput" class="file-label">📂 Import JSON</label>
    <input type="file" id="fileInput" accept=".json" />
    <button id="showNba2kBtn">NBA 2K23 MyCareer Tool</button>
    <button id="showBbgmBtn">BBGM MyCareer Upgrade Simulator</button>
    <button id="openBbgmBtn">📈 Open BBGM</button>
    <a href="https://discord.gg/5nPgxUn3H2" target="_blank" style="text-decoration:none;"><button>💬 Join BBGM Discord</button></a>
    <button id="showGlobalSettingsBtn">⚙️ Global Settings</button>
    <button id="showManualBtn">📚 Show Manual</button>
  </div>

  <!-- NBA 2K23 App Section -->
  <div class="app-section" id="nba2kApp">
    <div class="top-bar">
      <h1>NBA 2K23 MyCareer Tool</h1>
      <div>
        <button class="backToMenuBtn">⬅ Back to Menu</button>
        <button id="nba2k_exportBtn">💾 Export JSON</button>
        <label>
            <input type="file" class="file-input" id="nba2k_importFile" accept=".json">
            <button id="nba2k_importBtn">📂 Import JSON</button>
        </label>
      </div>
    </div>
    <div class="app-container">
      <div class="panel">
        <h2>Points Bank</h2>
        <label>Total Points Bank: <input type="number" id="nba2k_manualTotalPoints" value="0"></label>
        <div class="result">Total Points Bank: <span id="nba2k_pointsBankDisplay">0</span></div>
      </div>

      <div class="panel">
        <h2>Bonus Multipliers</h2>
        <label>Game Result: <select id="nba2k_gameResult"><option value="">- Select Here -</option><option value="win">Win</option><option value="otwin">OT Win</option><option value="lose">Lose</option><option value="otlose">OT Lose</option></select></label>
        <div id="nba2k_otCountBox" style="display:none;"><label>Overtime Count (1–6): <input type="number" id="nba2k_otCount" min="1" max="6" value="1"></label></div>
        <label>Opponent Type: <select id="nba2k_opponentType"><option value="">- Select Here -</option><option value="1">Easy</option><option value="1.25">Normal</option><option value="1.5">Hard</option><option value="1.75">1st in Conf</option><option value="2">1st/2nd in League</option><option value="3">All-Star Game</option></select></label>
        <label>Team Last Season: <select id="nba2k_teamHistory"><option value="">- Select Here -</option><option value="1">No Playoffs</option><option value="1.25">1st Round</option><option value="1.5">2nd Round</option><option value="1.75">Semifinalist</option><option value="1.9">Finalist</option><option value="2">Champs</option></select></label>
        <button id="nba2k_toggleMultiplierInfoBtn">ℹ️ Explanation</button>
        <div id="nba2k_multiplierInfo" style="display:none; margin-top:10px;"><p><strong>Game Result:</strong> Win ×1.5, OT Win adds +0.1 per OT (max 6), OT Lose ×1.25</p><p><strong>Opponent:</strong> Easy×1, Normal×1.25, Hard×1.5, 1st in Conf×1.75, Top‑2×2, All‑Star×3</p><p><strong>Team History:</strong> No Playoffs×1, 1stRn×1.25, 2ndRn×1.5, Semis×1.75, Finals×1.9, Champs×2</p></div>
      </div>

      <div class="panel">
        <h2>Game Stats</h2>
        <form id="nba2k_statsForm">
          <label>Points (gpts): <input type="number" name="gpts" value="0"></label>
          <label>Rebounds (greb): <input type="number" name="greb" value="0"></label>
          <label>Assists (gast): <input type="number" name="gast" value="0"></label>
          <label>Steals (gstl): <input type="number" name="gstl" value="0"></label>
          <label>Blocks (gblk): <input type="number" name="gblk" value="0"></label>
          <label>2-Point FGs (g2pt): <input type="number" name="g2pt" value="0"></label>
          <label>3-Point FGs (g3pt): <input type="number" name="g3pt" value="0"></label>
          <label>Free Throws (gfts): <input type="number" name="gfts" value="0"></label>
          <label>Turnovers (gtov): <input type="number" name="gtov" value="0"></label>
          <label>Fouls (gfls): <input type="number" name="gfls" value="0"></label>
          <label>+/- Score (gpm): <input type="number" name="gpm" value="0"></label>
          <label>Minutes (gm): <input type="number" name="gm" value="0"></label>
          <label>Base Points Increase: <input type="number" id="nba2k_basePointsIncrease" value="0"></label>
          <button type="submit">Calculate Points Earned</button>
        </form>
        <div class="result">Points Earned: <span id="nba2k_pointsEarned">0</span></div>
        <button id="nba2k_addPointsToBankBtn" class="success">Add to Bank</button>
      </div>

      <div class="panel">
        <h2>Attribute Upgrade Cost</h2>
        <div><h3><label class="checkbox-container"><input type="checkbox" id="nba2k_useOffense" checked><span class="switch"><span class="slider"></span></span>Offense</label></h3><label>Current Rating: <input type="number" id="nba2k_offenseCurrent" value="60"></label><label>Target Rating: <input type="number" id="nba2k_offenseTarget" value="70"></label><div class="result">Cost: <span id="nba2k_offenseCost">0</span></div></div>
        <div><h3><label class="checkbox-container"><input type="checkbox" id="nba2k_useDefense" checked><span class="switch"><span class="slider"></span></span>Defense</label></h3><label>Current Rating: <input type="number" id="nba2k_defenseCurrent" value="60"></label><label>Target Rating: <input type="number" id="nba2k_defenseTarget" value="70"></label><div class="result">Cost: <span id="nba2k_defenseCost">0</span></div></div>
        <div><h3><label class="checkbox-container"><input type="checkbox" id="nba2k_useAthletic" checked><span class="switch"><span class="slider"></span></span>Athleticism</label></h3><label>Current Rating: <input type="number" id="nba2k_athleticCurrent" value="60"></label><label>Target Rating: <input type="number" id="nba2k_athleticTarget" value="70"></label><div class="result">Cost: <span id="nba2k_athleticCost">0</span></div></div>
        <div><h3><label class="checkbox-container"><input type="checkbox" id="nba2k_useMental" checked><span class="switch"><span class="slider"></span></span>Mental</label></h3><label>Current Rating: <input type="number" id="nba2k_mentalCurrent" value="60"></label><label>Target Rating: <input type="number" id="nba2k_mentalTarget" value="70"></label><div class="result">Cost: <span id="nba2k_mentalCost">0</span></div></div>
        <button id="nba2k_calculateAllUpgradesBtn">Calculate All Upgrade Costs</button>
        <div class="result" id="nba2k_upgradeSummary"></div>
        <button id="nba2k_confirmUpgradeBtn" class="success">Confirm Upgrade</button>
        <label>Price Multiplier: <select id="nba2k_priceMultiplier"><option value="1">Not Valuable (1×)</option><option value="2">Valuable (2×)</option><option value="3">Very Valuable (3×)</option></select></label>
      </div>
    </div>
    <div class="bottom-bar">
        <!-- Kept for consistency, though buttons moved -->
    </div>
  </div>

  <!-- BBGM App Section -->
  <div class="app-section" id="bbgmApp">
    <div class="top-bar">
      <h1>BasketballGM MyCareer Tool</h1>
      <div>
        <button class="backToMenuBtn">⬅ Back to Menu</button>
        <button id="bbgm_exportBtn">💾 Export JSON</button>
        <label>
            <input type="file" class="file-input" id="bbgm_importFile" accept=".json">
            <button id="bbgm_importBtn">📂 Import JSON</button>
        </label>
        <label>
            <input type="file" class="file-input" id="bbgm_playerImportFile" accept=".json">
            <button id="bbgm_playerImportBtn">⛹️ Import BBGM Player & Convert Points</button>
        </label>
        <label class="checkbox-container" style="margin-left: 10px;">
            <input type="checkbox" id="bbgm_forceNewPlayerImport">
            <span class="switch"><span class="slider"></span></span>Force New Player Import
        </label>
        <button id="bbgm_exportModifiedPlayerBtn">💾 Export Modified Player</button>
      </div>
    </div>
    <div class="app-container">
      <div class="panel">
        <h2>Points Bank</h2>
        <label>Total Points Bank: <input type="number" id="bbgm_manualTotalPoints" value="0"></label>
        <div class="result">Total Points Bank: <span id="bbgm_pointsBankDisplay">0</span></div>
      </div>

      <div class="panel">
        <h2>Player Info & Season Stats</h2>
        <div class="result">Player Name: <span id="bbgm_playerNameDisplay">N/A</span></div>
        <div class="result">Age: <span id="bbgm_playerAgeDisplay">N/A</span></div>
        <div class="result">Position: <span id="bbgm_playerPosDisplay">N/A</span></div>
        <div class="result">Overall Rating: <span id="bbgm_playerOvrDisplay">N/A</span></div>
        <div class="result">Potential: <span id="bbgm_playerPotDisplay">N/A</span></div>
        <label>Select Season for Points:
            <select id="bbgm_seasonSelect" data-previous-season="">
            </select>
        </label>
        <div class="result">Points from Season: <span id="bbgm_seasonPointsEarned">0</span></div>
        <button id="bbgm_addSeasonPointsToBankBtn" class="success">Add Season Points to Bank</button>
      </div>

      <div class="panel">
        <h2>Bonus Multipliers</h2>
        <label>Regular Season Wins: <select id="bbgm_winsCategory">
            <option value="1">0-20 Wins (1.0×)</option>
            <option value="1.25">21-40 Wins (1.1375×)</option>
            <option value="1.5">41-50 Wins (1.275×)</option>
            <option value="1.75">51-60 Wins (1.4125×)</option>
            <option value="2">61+ Wins (1.55×)</option>
        </select></label>
        <label>Playoff Performance: <select id="bbgm_playoffPerformance">
            <option value="1">No Playoffs (1.0×)</option>
            <option value="1.05">Play-in (1.05×)</option>
            <option value="1.15">1st Round Exit (1.0825×)</option>
            <option value="1.35">2nd Round Exit (1.1925×)</option>
            <option value="1.55">Conf. Finals Exit (1.3025×)</option>
            <option value="1.75">Finals Exit (1.4125×)</option>
            <option value="2">Champions (1.55×)</option>
        </select></label>
        <button id="bbgm_toggleMultiplierInfoBtn">ℹ️ Explanation</button>
        <div id="bbgm_multiplierInfo" style="display:none; margin-top:10px;"><p><strong>Wins:</strong> 0-20(1.0×), 21-40(1.1375×), 41-50(1.275×), 51-60(1.4125×), 61+(1.55×)</p><p><strong>Playoffs:</strong> No Playoffs(1.0×), Play-in(1.05×), 1stR Exit(1.0825×), 2ndR Exit(1.1925×), ConfF Exit(1.3025×), Finals Exit(1.4125×), Champs(1.55×)</p></div>
      </div>

      <div class="panel">
        <h2>Game Stats (Manual Entry)</h2>
        <form id="bbgm_statsForm">
          <label>Points (gpts): <input type="number" name="gpts" value="0"></label>
          <label>Rebounds (greb): <input type="number" name="greb" value="0"></label>
          <label>Assists (gast): <input type="number" name="gast" value="0"></label>
          <label>Steals (gstl): <input type="number" name="gstl" value="0"></label>
          <label>Blocks (gblk): <input type="number" name="gblk" value="0"></label>
          <label>+/- Score (gpm): <input type="number" name="gpm" value="0"></label>
          <label>Minutes (gm): <input type="number" name="gm" value="0"></label>
          <label>Base Points Increase: <input type="number" id="bbgm_basePointsIncrease" value="0"></label>
          <button type="submit">Calculate Points Earned</button>
        </form>
        <div class="result">Points Earned: <span id="bbgm_pointsEarned">0</span></div>
        <button id="bbgm_addPointsToBankBtn" class="success">Add to Bank</button>
      </div>

      <div class="panel">
        <h2>Current Player Ratings</h2>
        <div id="bbgm_currentRatingsDisplay">
            <!-- Current ratings will be dynamically populated here -->
            <p>No player loaded.</p>
        </div>
      </div>

      <div class="panel">
        <h2>Attribute Upgrade Cost</h2>
        <label>Quick Select Attribute:
            <select id="bbgm_quickSelectAttribute">
                <!-- Options will be dynamically populated here -->
            </select>
        </label>
        <!-- Offensive Category -->
        <div id="bbgm_offensiveAttributes" class="bbgm-attribute-group">
            <h3><label class="checkbox-container"><input type="checkbox" id="bbgm_useOffensive" checked><span class="switch"><span class="slider"></span></span>Offensive Attributes</label></h3>
            <label>Select Attribute:
                <select id="bbgm_offensiveAttributeSelect">
                    <!-- Offensive attributes populated here -->
                </select>
            </label>
            <label><span>Current:</span> <input type="text" pattern="[0-9]*" inputmode="numeric" id="bbgm_currentOffensiveAttribute" value="0"></label>
            <label><span>Target:</span> <input type="text" pattern="[0-9]*" inputmode="numeric" id="bbgm_targetOffensiveAttribute" value="0" min="0" max="100"></label>
            <div class="result">Category Cost: <span id="bbgm_offenseCost">0</span></div>
        </div>
        <!-- Athleticism Category -->
        <div id="bbgm_athleticAttributes" class="bbgm-attribute-group">
            <h3><label class="checkbox-container"><input type="checkbox" id="bbgm_useAthletic" checked><span class="switch"><span class="slider"></span></span>Athleticism</label></h3>
            <label>Select Attribute:
                <select id="bbgm_athleticAttributeSelect">
                    <!-- Athleticism attributes populated here -->
                </select>
            </label>
            <label><span>Current:</span> <input type="text" pattern="[0-9]*" inputmode="numeric" id="bbgm_currentAthleticAttribute" value="0"></label>
            <label><span>Target:</span> <input type="text" pattern="[0-9]*" inputmode="numeric" id="bbgm_targetAthleticAttribute" value="0" min="0" max="100"></label>
            <div class="result">Category Cost: <span id="bbgm_athleticCost">0</span></div>
        </div>
        <!-- Skill Category -->
        <div id="bbgm_skillAttributes" class="bbgm-attribute-group">
            <h3><label class="checkbox-container"><input type="checkbox" id="bbgm_useSkill" checked><span class="switch"><span class="slider"></span></span>Skill Attributes</label></h3>
            <label>Select Attribute:
                <select id="bbgm_skillAttributeSelect">
                    <!-- Skill attributes populated here -->
                </select>
            </label>
            <label><span>Current:</span> <input type="text" pattern="[0-9]*" inputmode="numeric" id="bbgm_currentSkillAttribute" value="0"></label>
            <label><span>Target:</span> <input type="text" pattern="[0-9]*" inputmode="numeric" id="bbgm_targetSkillAttribute" value="0" min="0" max="100"></label>
            <div class="result">Category Cost: <span id="bbgm_skillCost">0</span></div>
        </div>
        <button id="bbgm_calculateAllUpgradesBtn">Calculate All Upgrade Costs</button>
        <div class="result" id="bbgm_upgradeSummary"></div>
        <button id="bbgm_confirmUpgradeBtn" class="success">Confirm Upgrade</button>
      </div>
      <!-- New Season Statistics Panel -->
      <div class="panel" id="bbgm_seasonStatsPanel">
        <h2>Season Statistics</h2>
        <div class="season-stats-tabs">
            <button id="bbgm_showRegularSeasonStatsBtn" class="active">Regular Season</button>
            <button id="bbgm_showPlayoffStatsBtn">Playoffs</button>
        </div>
        <div class="season-stats-content" id="bbgm_statsContentDisplay">
            <!-- Stats will be dynamically loaded here -->
            <p>Select a season and type of stats to display.</p>
        </div>
      </div>
    </div>
    <div class="bottom-bar">
        <!-- The old "Show Current Ratings (Popup)" button has been removed -->
        <button id="bbgm_generateReportBtn">✨ Generate Scouting Report</button>
        <button id="bbgm_generateRandomPlayerBtn">✨ Generate Random Player</button>
    </div>
  </div>

  <!-- Global Settings Section -->
  <div class="app-section" id="globalSettingsApp">
    <div class="top-bar"><h1>⚙️ Global Settings</h1><button class="backToMenuBtn">⬅ Back to Menu</button></div>
    <div class="app-container">
      <div class="panel">
        <h2>Appearance</h2>
        <button id="toggleDarkModeBtn">🌓 Toggle Dark Mode</button>
      </div>
      <div class="panel">
        <h2>Startup</h2>
        <label class="checkbox-container"><input type="checkbox" id="showTutorialOnStartup"><span class="switch"><span class="slider"></span></span>Show manual on startup</label>
      </div>
      <!-- Add more global settings here -->
    </div>
  </div>

  <!-- Manual Section -->
  <div class="app-section" id="manualApp">
    <div class="top-bar"><h1>📚 How to Use MyCareer Tools</h1><button class="backToMenuBtn">⬅ Back to Menu</button></div>
    <div class="app-container">
      <div class="panel">
        <h2>General Usage</h2>
        <ul>
          <li><strong>Import/Export JSON:</strong> Save and load your progress for both simulators.</li>
          <li><strong>Toggle Dark Mode:</strong> Switch between dark and light themes.</li>
          <li><label class="checkbox-container"><input type="checkbox" id="showTutorialOnStartup"><span class="switch"><span class="slider"></span></span>Show manual on startup</label></li>
        </ul>
      </div>
      <div class="panel">
        <h2>NBA 2K23 & BBGM Tools</h2>
        <ul>
          <li><strong>Points Bank:</strong> Manually adjust your total points.</li>
          <li><strong>Bonus Multipliers:</strong> Select game results, opponent type, etc., to apply multipliers.</li>
          <li><strong>Game Stats:</strong> Input stats, click "Calculate Points Earned". The result is shown but <strong>not</strong> added to your bank. Click "Add to Bank" to add the points.</li>
          <li><strong>Attribute Upgrade Cost:</strong> Enter current/target ratings, use checkboxes to select categories, and click "Calculate All Upgrade Costs". Then click "Confirm Upgrade" to spend the points.</li>
        </ul>
      </div>
      <div class="panel">
        <h2>BBGM Special Features</h2>
        <ul>
          <li><strong>Import BBGM Player:</strong> Load a player JSON file. You can select a season to convert its stats into points, which are automatically added to your bank. The player's current ratings will populate the upgrade fields.</li>
          <li><strong>Export Modified Player:</strong> After upgrading, export a new JSON file with the updated ratings.</li>
          <li><strong>Current Player Ratings Panel:</strong> View a detailed list of the imported player's attributes directly on the page.</li>
          <li><strong>Generate Scouting Report:</strong> Get an AI-powered scouting report on your imported player.</li>
        </ul>
      </div>
      <!-- New Custom Notes Panel -->
      <div class="panel">
        <h2>Your Custom Notes</h2>
        <div contenteditable="true" style="min-height: 100px; border: 1px solid var(--bg); padding: 10px; border-radius: 5px; background-color: var(--bg); color: var(--text);">
          <h2>How to use! (BBGM only, some features explained her are usuable in NBA2k version)</h2>
          <p>The UI is very simple, but: There are 6 panels, 5 at the top and 1 huge one at the bottom. [from left to right]</p>
          <p>First panel: it shows your total points bank, this shows how much points you have for upgrading your player.</p>
          <p>Second panel: It shows your player and its overall/potential, name and position. </p>
          <p>Third panel: Bonus multipliers! These affect your points total, for manual and automatic. It depends on your team's record and placement. A better version of this will be made soon.</p>
          <p>Fourth panel: Season stats but manual entry, in case the automatic conversion doesnt work, you can use this instead.</p>
          <p>Fifth panel: Current player ratings: Shows your player's ratings, and it will reflect your upgrades.</p>
          <p>Sixth, largest panel: For upgrading your player! Use the 3 categories (Offensive, Skills and Athleticism) to pick an attribute and upgrade. A formula for this will be improved later on.</p>
          <h3>Buttons!</h3>
          <p>Export/Import JSON: Exports or Imports JSON but its only usable for this site.</p>
          <p>Import player and convert points/Export modified player: Import your BBGM player (not season) for automatic conversion and upgrades, and once you are done you can export the upgraded player.</p>
          <p>Generate scouting report: Uses Google's Gemini AI to create a scouting report for your player.</p>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // --- APP STATE AND CONFIGURATION ---

    const VALUABLE_MULTIPLIER = 1.5; // Multiplier for valuable BBGM attributes (3pt, OIQ, DIQ)
    const PLAYOFF_POINTS_MULTIPLIER = 1.15; // Multiplier for playoff stats points
    const POINTS_PER_GP = 100; // Points for each game played
    const GLOBAL_MULTIPLIER_NERF = 0.55; // Nerf all bonus multipliers by 45% (1 - 0.45)
    const PRICING_NERF = 0.75; // Nerf all upgrade pricing by 25% (1 - 0.25)

    // Global variable to store the imported BBGM player JSON
    let currentBBGMPlayerJson = null;
    let currentBBGMPlayerId = ""; // Stores the ID of the currently loaded BBGM player (starts blank)
    let bbgmAttributeTargets = {}; // Stores target ratings for all BBGM attributes
    let currentBBGMSeasonRatings = null; // Stores the ratings object for the currently selected season
    let bbgmMultiplierWarningShown = false; // Flag to track if multiplier warning has been shown for BBGM
    let currentStatsView = 'regularSeason'; // 'regularSeason' or 'playoffs'

    // Default template player for BBGM if no file is imported
    const defaultBBGMPlayer = {
        players: [{
            pid: "default_player_1", // Added a default player ID
            firstName: "Template",
            lastName: "Player",
            age: 20,
            pos: "PG",
            ovr: 65, // Overall rating
            pot: 75, // Potential rating
            ratings: [{ // Ratings is now an array, even for the default
                season: 2024,
                stre: 50, spd: 60, jmp: 65, endu: 70, // Athleticism
                ins: 60, dnk: 55, ft: 70, fg: 60, tp: 60, // Offensive
                oiq: 65, diq: 65, drb: 70, pss: 70, reb: 50, // Skill
                ovr: 65, pos: "PG", pot: 75, // Added to ratings for consistency, though main player object is source
                hgt: 75, // Default height
            }],
            stats: [ // Basic stats for one season for point conversion
                {
                    season: 2024,
                    playoffs: false,
                    fg: 100, tp: 30, ft: 50, reb: 150, ast: 200, stl: 50, blk: 20, tov: 80, pf: 60, pm: 100, gp: 82, min: 2000
                }
            ]
        }]
    };

    // Helper to get the correct cost based on tier and multipliers
    const getAdjustedCost = (r, isValuable = false) => {
        let baseCost;
        if (r < 40) baseCost = 400;
        else if (r < 50) baseCost = 1050;
        else if (r < 60) baseCost = 2250;
        else if (r < 70) baseCost = 4950;
        else if (r < 80) baseCost = 9850;
        else if (r < 90) baseCost = 18950;
        else baseCost = 35155;

        let adjustedCost = baseCost / PRICING_NERF;
        if (isValuable) {
            adjustedCost = adjustedCost / VALUABLE_MULTIPLIER;
        }
        return adjustedCost;
    };

    // Define point values and upgrade costs for both apps
    const appData = {
      nba2k: {
        pointValues: {
          gpts: 2, greb: 5, gast: 5, gstl: 10, gblk: 10,
          g2pt: 2, g3pt: 3, gfts: 1, gtov: -2, gfls: -1, gpm: 5, gm: 1
        },
        upgradeCostPerPoint: {
          offense: r => (r < 60 ? 25 : r <= 79 ? 40 : r <= 89 ? 70 : r <= 94 ? 125 : 50),
          mental: r => (r < 60 ? 25 : r <= 79 ? 37 : r <= 89 ? 68 : r <= 94 ? 120 : 45),
          defense: r => (r < 60 ? 25 : r <= 79 ? 51 : r <= 89 ? 85 : r <= 94 ? 135 : 75),
          athletic: r => (r < 60 ? 30 : r <= 79 ? 65 : r <= 89 ? 105 : r <= 94 ? 155 : 100)
        },
        upgradeCategories: [
          { key: 'offense', useId: 'useOffense', baseMultiplier: 1.25 },
          { key: 'defense', useId: 'useDefense', baseMultiplier: 1.5 },
          { key: 'athletic', useId: 'useAthletic', baseMultiplier: 2.5 },
          { key: 'mental', useId: 'useMental', baseMultiplier: 2.0 }
        ]
      },
      bbgm: {
        // BBGM game stats point values (aligned with NBA2K as requested)
        pointValues: { gpts: 2, greb: 5, gast: 5, gstl: 10, gblk: 10, gpm: 5, gm: 1 },
        // BBGM stat conversion for imported player files (aligned with NBA2K as requested)
        statConversionPoints: { 
            twoPointersMade: 2, // Calculated from fg - tp
            threePointersMade: 3, // From tp
            freeThrowsMade: 1, // From ft
            reb: 5, // Rebounds
            ast: 5, // Assists
            stl: 10, // Steals
            blk: 10, // Blocks
            tov: -2, // Turnovers
            pf: -1, // Personal Fouls (gfls in NBA2K)
            pm: 5, // Plus/Minus
            min: 1, // Minutes
            // gp is handled separately for POINTS_PER_GP
        },
        upgradeCostPerAttribute: {
            stre: r => getAdjustedCost(r, false),
            spd: r => getAdjustedCost(r, false),
            jmp: r => getAdjustedCost(r, false),
            endu: r => getAdjustedCost(r, false),

            ins: r => getAdjustedCost(r, false),
            dnk: r => getAdjustedCost(r, false),
            ft: r => getAdjustedCost(r, false),
            fg: r => getAdjustedCost(r, false),
            tp: r => getAdjustedCost(r, true), // Valuable
            oiq: r => getAdjustedCost(r, true), // Valuable
            diq: r => getAdjustedCost(r, true), // Valuable
            drb: r => getAdjustedCost(r, false),
            pss: r => getAdjustedCost(r, false),
            reb: r => getAdjustedCost(r, false),
        },
        upgradeCategories: [
          { key: 'offensive', label: 'Offensive', attributes: ['ins', 'dnk', 'ft', 'fg', 'tp'], useId: 'useOffensive' },
          { key: 'athletic', label: 'Athleticism', attributes: ['stre', 'spd', 'jmp', 'endu'], useId: 'useAthletic' },
          { key: 'skill', label: 'Skill', attributes: ['oiq', 'diq', 'drb', 'pss', 'reb'], useId: 'useSkill' }
        ],
        // Map attribute keys to more readable labels
        attributeLabels: {
            stre: 'Strength', spd: 'Speed', jmp: 'Jumping', endu: 'Endurance',
            ins: 'Inside Scoring', dnk: 'Dunking', ft: 'Free Throw', fg: 'Field Goal', tp: '3-Point',
            oiq: 'Offensive IQ', diq: 'Defensive IQ', drb: 'Dribbling', pss: 'Passing', reb: 'Rebounding'
        }
      }
    };

    // Award points for BBGM
    const AWARD_POINTS = {
        "Most Valuable Player": 50000,
        "Defensive Player of the Year": 30000,
        "Sixth Man of the Year": 15000,
        "Rookie of the Year": 15000,
        "All-League First Team": 20000,
        "All-League Second Team": 15000,
        "All-League Third Team": 10000,
        "All-Defensive First Team": 12000,
        "All-Defensive Second Team": 8000,
        "All-Rookie First Team": 10000,
        "All-Rookie Second Team": 5000
    };

    // --- DOM ELEMENT SELECTOR HELPER ---
    function getAppElements(appId) {
      // console.log(`[getAppElements] Getting elements for appId: ${appId}`); // Reduced logging
      const prefix = `${appId}_`;
      const elements = {
        manualTotalPoints: document.getElementById(`${prefix}manualTotalPoints`),
        pointsBankDisplay: document.getElementById(`${prefix}pointsBankDisplay`),
        statsForm: document.getElementById(`${prefix}statsForm`),
        basePointsIncrease: document.getElementById(`${prefix}basePointsIncrease`),
        pointsEarned: document.getElementById(`${prefix}pointsEarned`),
        addPointsToBankBtn: document.getElementById(`${prefix}addPointsToBankBtn`),
        upgradeSummary: document.getElementById(`${prefix}upgradeSummary`),
      };
      if (appId === 'nba2k') {
        elements.gameResult = document.getElementById(`${prefix}gameResult`);
        elements.otCountBox = document.getElementById(`${prefix}otCountBox`);
        elements.otCount = document.getElementById(`${prefix}otCount`);
        elements.opponentType = document.getElementById(`${prefix}opponentType`);
        elements.teamHistory = document.getElementById(`${prefix}teamHistory`);
        elements.priceMultiplier = document.getElementById(`${prefix}priceMultiplier`);
        elements.getUpgradeElements = (categoryKey) => {
            const categoryConfig = appData[appId].upgradeCategories.find(c => c.key === categoryKey);
            if (!categoryConfig) {
                console.error(`[getAppElements] Category config not found for key: ${categoryKey} in ${appId}`);
                return {};
            }
            return {
                use: document.getElementById(`${prefix}${categoryConfig.useId}`),
                costDisplay: document.getElementById(`${prefix}${categoryConfig.key}Cost`),
                current: document.getElementById(`${prefix}${categoryKey}Current`),
                target: document.getElementById(`${prefix}${categoryKey}Target`)
            };
        };
      } else { // BBGM specific elements
        elements.winsCategory = document.getElementById(`${prefix}winsCategory`);
        elements.playoffPerformance = document.getElementById(`${prefix}playoffPerformance`);
        elements.forceNewPlayerImport = document.getElementById(`${prefix}forceNewPlayerImport`); // New checkbox
        elements.quickSelectAttribute = document.getElementById(`${prefix}quickSelectAttribute`); // New dropdown
        elements.playerNameDisplay = document.getElementById(`${prefix}playerNameDisplay`); // New
        elements.playerAgeDisplay = document.getElementById(`${prefix}playerAgeDisplay`); // New: Player Age
        elements.playerPosDisplay = document.getElementById(`${prefix}playerPosDisplay`); // New
        elements.playerOvrDisplay = document.getElementById(`${prefix}playerOvrDisplay`); // New
        elements.playerPotDisplay = document.getElementById(`${prefix}playerPotDisplay`); // New
        elements.seasonSelect = document.getElementById(`${prefix}seasonSelect`); // New
        elements.seasonPointsEarned = document.getElementById(`${prefix}seasonPointsEarned`); // New
        elements.addSeasonPointsToBankBtn = document.getElementById(`${prefix}addSeasonPointsToBankBtn`); // New
        elements.currentRatingsDisplay = document.getElementById(`${prefix}currentRatingsDisplay`); // New
        
        // Consolidated Season Stats Panel elements
        elements.statsContentDisplay = document.getElementById(`${prefix}statsContentDisplay`);
        elements.showRegularSeasonStatsBtn = document.getElementById(`${prefix}showRegularSeasonStatsBtn`);
        elements.showPlayoffStatsBtn = document.getElementById(`${prefix}showPlayoffStatsBtn`);
        
        // BBGM category-specific attribute selectors and current/target inputs
        elements.getUpgradeElements = (categoryKey) => { // Renamed from getCategoryAttributeElements to be consistent
            const categoryConfig = appData[appId].upgradeCategories.find(c => c.key === categoryKey);
            if (!categoryConfig) {
                console.error(`[getAppElements] Category config not found for key: ${categoryKey} in ${appId}`);
                return {};
            }
            return {
                use: document.getElementById(`${prefix}${categoryConfig.useId}`),
                select: document.getElementById(`${prefix}${categoryKey}AttributeSelect`),
                current: document.getElementById(`${prefix}current${categoryKey.charAt(0).toUpperCase() + categoryKey.slice(1)}Attribute`),
                target: document.getElementById(`${prefix}target${categoryKey.charAt(0).toUpperCase() + categoryKey.slice(1)}Attribute`),
                costDisplay: document.getElementById(`${prefix}${categoryKey}Cost`)
            };
        };
      }
      // console.log(`[getAppElements] Elements for ${appId} retrieved.`); // Reduced logging
      return elements;
    }

    // --- DATA HANDLING (IMPORT/EXPORT/LOCALSTORAGE) ---
    function saveToLocal(key, value) {
      try {
        localStorage.setItem('mycareer_' + key, JSON.stringify(value));
        // console.log(`[saveToLocal] Saved: mycareer_${key}`, value); // Reduced logging
      } 
      catch (e) { console.error(`[saveToLocal] Error saving mycareer_${key}:`, e); }
    }

    function loadFromLocal(key) {
      try {
        const item = localStorage.getItem('mycareer_' + key);
        const parsedItem = item ? JSON.parse(item) : null;
        // console.log(`[loadFromLocal] Loaded: mycareer_${key}`, parsedItem); // Reduced logging
        return parsedItem;
      } catch (e) {
        console.error(`[loadFromLocal] Error parsing mycareer_${key}:`, e);
        return null;
      }
    }

    function saveCurrentAppData(appId) {
        // console.log(`[saveCurrentAppData] Saving current data for appId: ${appId}`); // Reduced logging
        const elements = getAppElements(appId);
        const data = {
            app: appId,
            totalPoints: elements.manualTotalPoints?.value || '0', // Changed default to 0
            basePointsIncrease: elements.basePointsIncrease?.value || '0',
            stats: {},
            upgrade: {}
        };

        if (appId === 'nba2k') {
            data.gameResult = elements.gameResult?.value || '';
            data.otCount = elements.otCount?.value || '1';
            data.opponentType = elements.opponentType?.value || '';
            data.teamHistory = elements.teamHistory?.value || '';
            data.upgrade.priceMultiplier = elements.priceMultiplier?.value || '1';

            appData[appId].upgradeCategories.forEach(category => {
                const upgradeElements = elements.getUpgradeElements(category.key);
                data.upgrade[category.key] = {
                    use: upgradeElements.use ? upgradeElements.use.checked : false,
                    current: upgradeElements.current?.value || '60',
                    target: upgradeElements.target?.value || '70'
                };
            });
        } else if (appId === 'bbgm') {
            data.winsCategory = elements.winsCategory?.value || '';
            data.playoffPerformance = elements.playoffPerformance?.value || '';
            data.currentBBGMPlayerJson = currentBBGMPlayerJson; // Save the full player JSON
            data.currentBBGMPlayerId = currentBBGMPlayerId; // Save the current player ID
            data.bbgmAttributeTargets = bbgmAttributeTargets; // Save the global target object
            data.selectedSeason = elements.seasonSelect?.value || ''; // Save selected season
            data.currentStatsView = currentStatsView; // Save current stats view (regular/playoffs)

            // Save the 'use' state for BBGM categories
            appData[appId].upgradeCategories.forEach(category => {
                const upgradeElements = elements.getUpgradeElements(category.key);
                data.upgrade[category.key] = {
                    use: upgradeElements.use ? upgradeElements.use.checked : false,
                };
            });
        }

        if (elements.statsForm) {
            for (const el of elements.statsForm.elements) {
                if (el.name && el.type !== 'submit') { data.stats[el.name] = el.value; }
            }
        }
        saveToLocal(`data_${appId}`, data);
        // console.log(`[saveCurrentAppData] Data saved for ${appId}.`); // Reduced logging
    }

    function loadDataIntoApp(data, targetAppId) {
        // console.log(`[loadDataIntoApp] Loading data into ${targetAppId} app.`); // Reduced logging
        const elements = getAppElements(targetAppId);
        
        if (elements.manualTotalPoints) elements.manualTotalPoints.value = data.totalPoints || 0; // Changed default to 0
        if (elements.basePointsIncrease) elements.basePointsIncrease.value = data.basePointsIncrease || 0;

        if (targetAppId === 'nba2k') {
            if (elements.gameResult) elements.gameResult.value = data.gameResult || '';
            if (elements.otCount) elements.otCount.value = data.otCount || '1';
            if (elements.opponentType) elements.opponentType.value = data.opponentType || '';
            if (elements.teamHistory) elements.teamHistory.value = data.teamHistory || '';
            if (elements.priceMultiplier) elements.priceMultiplier.value = data.upgrade?.priceMultiplier || '1';

            if (data.upgrade) {
                appData[targetAppId].upgradeCategories.forEach(category => {
                    const upgradeElements = elements.getUpgradeElements(category.key);
                    const loadedCat = data.upgrade[category.key];
                    if (loadedCat) {
                        if (upgradeElements.use) upgradeElements.use.checked = loadedCat.use;
                        if (upgradeElements.current) upgradeElements.current.value = loadedCat.current;
                        if (upgradeElements.target) upgradeElements.target.value = loadedCat.target;
                        // console.log(`[loadDataIntoApp] Set NBA2K upgrade category ${category.key}: Current=${loadedCat.current}, Target=${loadedCat.target}, Use=${loadedCat.use}`); // Reduced logging
                    }
                });
            }
        } else if (targetAppId === 'bbgm') {
            if (elements.winsCategory) elements.winsCategory.value = data.winsCategory || '';
            if (elements.playoffPerformance) elements.playoffPerformance.value = data.playoffPerformance || '';
            currentBBGMPlayerJson = data.currentBBGMPlayerJson || null;
            currentBBGMPlayerId = data.currentBBGMPlayerId || ""; // Load player ID, default to blank
            bbgmAttributeTargets = data.bbgmAttributeTargets || {}; // Load the global target object
            currentStatsView = data.currentStatsView || 'regularSeason'; // Load current stats view
            // console.log(`[loadDataIntoApp] BBGM Player JSON loaded:`, currentBBGMPlayerJson ? currentBBGMPlayerJson.players[0].name : 'None'); // Reduced logging
            // console.log(`[loadDataIntoApp] BBGM Attribute Targets loaded:`, bbgmAttributeTargets); // Reduced logging

            // Update player name and overall display
            updateBBGMPlayerInfoDisplay();

            // Ensure BBGM UI is updated before calculating upgrades
            createBBGMIndividualAttributeInputs(); // Re-create inputs if not present
            populateBBGMAttributeQuickSelect(); // Populate quick select dropdown
            
            // Set currentBBGMSeasonRatings based on the loaded selected season
            if (currentBBGMPlayerJson && data.selectedSeason) {
                currentBBGMSeasonRatings = getRatingsForSeason(parseInt(data.selectedSeason));
            } else if (currentBBGMPlayerJson) {
                // If no specific season was saved, default to latest ratings from the player JSON
                currentBBGMSeasonRatings = getLatestPlayerRatings(currentBBGMPlayerJson.players[0]);
            } else {
                currentBBGMSeasonRatings = null;
            }

            updateBBGMCurrentRatingsUI(); // This will also update the displayed current/target inputs based on selected attributes
            populateBBGMSeasonSelect(data.selectedSeason); // Pass selected season to re-select it
            calculatePointsFromSelectedSeason(); // Recalculate points for the re-selected season
            updateBBGMSeasonStatsPanel(); // Update the new season stats panel
        }

        if (elements.statsForm && data.stats) {
            for (const key in data.stats) {
                if (elements.statsForm.elements[key]) {
                    elements.statsForm.elements[key].value = data.stats[key];
                    // console.log(`[loadDataIntoApp] Set stat ${key}: ${data.stats[key]}`); // Reduced logging
                }
            }
        }

        updatePointsBankDisplay(targetAppId);
        calculatePointsEarned(targetAppId);
        calculateAllUpgrades(targetAppId); // Call this for both apps now
        if (targetAppId === 'nba2k') toggleOTBox(targetAppId);
        // console.log(`[loadDataIntoApp] Data loaded and UI updated for ${targetAppId}.`); // Reduced logging
    }

    function exportData(appId) {
        console.log(`[exportData] Called for appId: ${appId}`);
        saveCurrentAppData(appId); // Ensure data is fresh
        const dataToExport = loadFromLocal(`data_${appId}`);

        if (!dataToExport) {
            showMessage("No data to export for this app.", 'info');
            console.warn(`[exportData] No data found for ${appId} to export.`);
            return;
        }

        const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: "application/json" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `${appId}_save_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        showMessage("Data exported successfully!", 'success');
        console.log(`[exportData] Data for ${appId} exported to ${link.download}`);
    }

    function importData(event, targetAppId) {
        console.log(`[importData] Called for targetAppId: ${targetAppId}`);
        const file = event.target.files[0];
        if (!file) {
            console.log("[importData] No file selected.");
            return;
        }
        const reader = new FileReader();
        reader.onload = e => {
            console.log(`[importData] File read complete for ${file.name}.`);
            try {
                const data = JSON.parse(e.target.result);
                console.log(`[importData] JSON parsed successfully.`);
                if (data.app !== targetAppId) {
                    alert(`This file is for ${data.app.toUpperCase()} and cannot be imported into ${targetAppId.toUpperCase()}.`);
                    console.warn(`[importData] Mismatched app ID. Expected ${targetAppId}, got ${data.app}.`);
                    return;
                }
                loadDataIntoApp(data, targetAppId);
                saveToLocal(`data_${targetAppId}`, data); // Save imported data to local storage
                showMessage("Data imported successfully!", 'success');
                console.log(`[importData] Data for ${targetAppId} imported successfully.`);
            } catch (err) {
                alert("Invalid file format or data structure.");
                console.error("[importData] Error during file read or JSON parse:", err);
            }
        };
        reader.onerror = (e) => {
            console.error(`[importData] FileReader error:`, e);
            alert("Error reading file. Please try again.");
        };
        reader.readAsText(file);
        event.target.value = ''; // Clear the file input to allow re-importing the same file
        console.log(`[importData] FileReader initiated for ${file.name}.`);
    }

    function handleMainMenuFileImport(event) {
        console.log("[handleMainMenuFileImport] Called.");
        const file = event.target.files[0];
        if (!file) {
            console.log("[handleMainMenuFileImport] No file selected.");
            return;
        }
        const reader = new FileReader();
        reader.onload = e => {
            console.log(`[handleMainMenuFileImport] File read complete for ${file.name}.`);
            try {
                const data = JSON.parse(e.target.result);
                console.log(`[handleMainMenuFileImport] JSON parsed successfully.`);
                if (data.app === 'nba2k' || data.app === 'bbgm') {
                    console.log(`[handleMainMenuFileImport] Detected app: ${data.app}. Switching and loading data.`);
                    showApp(data.app);
                    // Delay load to ensure DOM elements are ready after showApp
                    setTimeout(() => {
                        loadDataIntoApp(data, data.app);
                        saveToLocal(`data_${data.app}`, data);
                    }, 100);
                } else {
                    alert("Invalid app data in JSON. File must be for NBA2K or BBGM.");
                    console.warn("[handleMainMenuFileImport] Invalid app ID in imported JSON.");
                }
            } catch (err) {
                alert("Invalid file format or data structure.");
                console.error("[handleMainMenuFileImport] Error during file read or JSON parse:", err);
            }
        };
        reader.onerror = (e) => {
            console.error(`[handleMainMenuFileImport] FileReader error:`, e);
            alert("Error reading file. Please try again.");
        };
        reader.readAsText(file);
        event.target.value = ''; // Clear the file input
        console.log(`[handleMainMenuFileImport] FileReader initiated for ${file.name}.`);
    }

    // --- CORE LOGIC & CALCULATIONS ---

    function calculatePointsEarned(appId) {
      // console.log(`[calculatePointsEarned] Called for appId: ${appId}`); // Reduced logging
      const elements = getAppElements(appId);
      const appSpecificData = appData[appId];
      const form = elements.statsForm;
      let earnedFromStats = 0;
      let detailedLog = ``; // Initialize empty, will only add final summary

      if (form) {
        for (let key in appSpecificData.pointValues) {
          const input = form.elements[key];
          if (input) {
            const inputValue = parseInt(input.value) || 0;
            const pointValue = appSpecificData.pointValues[key];
            const statPoints = inputValue * pointValue;
            earnedFromStats += statPoints;
            // Removed individual stat logging
          }
        }
      }
      detailedLog += `Points from stats: ${earnedFromStats}\n`;

      let finalMultiplier = 1;
      if (appId === 'nba2k') {
        const result = elements.gameResult?.value || '';
        const opp = parseFloat(elements.opponentType?.value) || 1;
        const team = parseFloat(elements.teamHistory?.value) || 1;
        let gameResultMultiplier = 1;
        if (result === "win") gameResultMultiplier = 1.5;
        else if (result === "otwin") {
            const otCount = Math.min(6, parseInt(elements.otCount?.value || '1') || 1);
            gameResultMultiplier = 1.5 + (0.1 * otCount);
        }
        else if (result === "otlose") gameResultMultiplier = 1.25;
        finalMultiplier = gameResultMultiplier * opp * team;
        detailedLog += `NBA2K Multipliers: Game Result=${gameResultMultiplier}, Opponent=${opp}, Team=${team}\n`;
      } else if (appId === 'bbgm') {
        const winsCategory = elements.winsCategory?.value || '1'; // Default to 1 if not selected
        const playoffPerformance = elements.playoffPerformance?.value || '1'; // Default to 1 if not selected
        
        // Calculate the effective multiplier for each category, ensuring it's >= 1
        const winsMult = 1 + (parseFloat(winsCategory) - 1) * GLOBAL_MULTIPLIER_NERF;
        const playoffMult = 1 + (parseFloat(playoffPerformance) - 1) * GLOBAL_MULTIPLIER_NERF;

        finalMultiplier = winsMult * playoffMult; // Multiply the adjusted multipliers
        detailedLog += `BBGM Multipliers: Wins=${winsMult.toFixed(4)}, Playoff=${playoffMult.toFixed(4)}\n`;
      }

      let total = Math.round(earnedFromStats * finalMultiplier); // Apply multiplier first
      detailedLog += `Points after multipliers: ${total}\n`;

      const baseIncrease = parseInt(elements.basePointsIncrease?.value || '0') || 0;
      total += baseIncrease; // Then add base increase (not affected by multipliers)
      detailedLog += `Base Points Increase: ${baseIncrease}\n`;
      detailedLog += `Total Points Earned: ${total}\n`;
      // console.log(`[calculatePointsEarned] Summary for ${appId}:\n${detailedLog}`); // Reduced logging
      
      if (elements.pointsEarned) {
        elements.pointsEarned.innerText = total;
        elements.pointsEarned.dataset.points = total; // Store for 'Add to Bank'
        // console.log(`[calculatePointsEarned] Displayed points earned: ${total}`); // Reduced logging
      }
      saveCurrentAppData(appId);
    }

    function addPointsToBank(appId) {
        console.log(`[addPointsToBank] Called for appId: ${appId}`);
        const elements = getAppElements(appId);
        const pointsToAdd = parseInt(elements.pointsEarned?.dataset.points || '0');
        const bankInput = elements.manualTotalPoints;
        
        if (!bankInput) {
            console.error(`[addPointsToBank] Points bank input not found for ${appId}.`);
            return;
        }

        if (appId === 'bbgm') {
            const winsCategory = elements.winsCategory?.value || '';
            const playoffPerformance = elements.playoffPerformance?.value || '';
            if ((winsCategory === "" || playoffPerformance === "") && !bbgmMultiplierWarningShown) {
                showMessage("Please select values for 'Regular Season Wins' and 'Playoff Performance' multipliers for extra points. Click 'Add to Bank' again to proceed without multipliers.", 'warning');
                bbgmMultiplierWarningShown = true; // Set flag to true after first warning
                return; // Stop execution on first warning
            }
        }

        const currentBankValue = parseInt(bankInput.value) || 0;
        bankInput.value = currentBankValue + pointsToAdd;
        console.log(`[addPointsToBank] Adding ${pointsToAdd} points. Old bank: ${currentBankValue}, New bank: ${bankInput.value}`);
        
        updatePointsBankDisplay(appId);
        showMessage(`${pointsToAdd} points added to your bank! Total: ${bankInput.value}`, 'success');
        saveCurrentAppData(appId); // Save state after adding points
        bbgmMultiplierWarningShown = false; // Reset after successful addition
    }

    function calculateAllUpgrades(appId) {
      // console.log(`[calculateAllUpgrades] Called for appId: ${appId}`); // Reduced logging
      const elements = getAppElements(appId);
      const appSpecificData = appData[appId];
      let totalCost = 0;
      const bank = parseInt(elements.manualTotalPoints?.value || '0') || 0;
      const priceMultiplier = (appId === 'nba2k' ? parseFloat(elements.priceMultiplier?.value) : 1) || 1;
      // console.log(`[calculateAllUpgrades] Initial bank: ${bank}, Price Multiplier (NBA2K only): ${priceMultiplier}`); // Reduced logging

      if (appId === 'nba2k') {
          for (let category of appSpecificData.upgradeCategories) {
            // console.log(`[calculateAllUpgrades] Processing category: ${category.key}`); // Reduced logging
            const upgradeElements = elements.getUpgradeElements(category.key);
            const useCategory = upgradeElements.use ? upgradeElements.use.checked : false;
            let categoryTotalCost = 0;

            if (!useCategory) {
              if (upgradeElements.costDisplay) upgradeElements.costDisplay.innerText = "Ignored";
              // console.log(`[calculateAllUpgrades] Category ${category.key} ignored.`); // Reduced logging
              continue;
            }

            const current = parseInt(upgradeElements.current?.value || '0');
            const target = parseInt(upgradeElements.target?.value || '0');
            // console.log(`[calculateAllUpgrades] NBA2K - ${category.key}: Current: ${current}, Target: ${target}`); // Reduced logging
            if (current >= target) {
                if (upgradeElements.costDisplay) upgradeElements.costDisplay.innerText = "Invalid";
                console.warn(`[calculateAllUpgrades] NBA2K - Invalid target for ${category.key}. Current >= Target.`);
                continue;
            }
            const costFunction = appSpecificData.upgradeCostPerPoint[category.key];
            if (typeof costFunction !== 'function') {
                console.error(`[calculateAllUpgrades] NBA2K - Cost function for ${category.key} is not defined.`);
                if (upgradeElements.costDisplay) upgradeElements.costDisplay.innerText = "Error";
                continue;
            }
            for (let i = current + 1; i <= target; i++) {
                const stepCost = costFunction(i) * category.baseMultiplier * priceMultiplier;
                categoryTotalCost += stepCost;
                // console.log(`[calculateAllUpgrades] NBA2K - ${category.key} (level ${i}): Step cost: ${stepCost}`); // Reduced logging
            }
            if (upgradeElements.costDisplay) upgradeElements.costDisplay.innerText = Math.round(categoryTotalCost);
            totalCost += categoryTotalCost;
            // console.log(`[calculateAllUpgrades] ${category.key} total cost: ${Math.round(categoryTotalCost)}`); // Reduced logging
          }
      } else if (appId === 'bbgm') {
            // If no player is loaded, use the manually set current values from bbgmAttributeTargets
            const playerRatingsSource = currentBBGMPlayerJson && currentBBGMSeasonRatings ? currentBBGMSeasonRatings : bbgmAttributeTargets;

            if (!playerRatingsSource || Object.keys(playerRatingsSource).length === 0) {
                if (elements.upgradeSummary) elements.upgradeSummary.innerHTML = "Set attributes or load a player to calculate upgrade costs.";
                // Reset all category costs to 0 if no player or attributes loaded
                appData.bbgm.upgradeCategories.forEach(category => {
                    const categoryElements = elements.getUpgradeElements(category.key);
                    if (categoryElements.costDisplay) categoryElements.costDisplay.innerText = "0";
                });
                console.warn(`[calculateAllUpgrades] BBGM - No player or attributes loaded/set.`);
                return;
            }
            
            for (let category of appSpecificData.upgradeCategories) {
                const categoryElements = elements.getUpgradeElements(category.key);
                const useCategory = categoryElements.use ? categoryElements.use.checked : false; // Get state of checkbox

                let categoryTotalCost = 0; // Initialize for each category

                if (!useCategory) { // If category is not checked, its cost is 0
                    if (categoryElements.costDisplay) categoryElements.costDisplay.innerText = "Ignored";
                    continue; // Skip calculation for this category
                }

                for (const attrKey of category.attributes) {
                    // Use the current rating from the player JSON if loaded, otherwise from bbgmAttributeTargets
                    const currentAttrRating = currentBBGMPlayerJson && currentBBGMSeasonRatings ? 
                                              (currentBBGMSeasonRatings[attrKey] || 0) : 
                                              (parseInt(bbgmAttributeTargets[attrKey]) || 0);
                    
                    const targetAttrRating = parseInt(bbgmAttributeTargets[attrKey] || currentAttrRating); // Use stored target or current

                    // console.log(`[calculateAllUpgrades] BBGM -   Attribute ${attrKey}: Current: ${currentAttrRating}, Target: ${targetAttrRating}`); // Reduced logging
                    if (currentAttrRating >= targetAttrRating) {
                        // If target is less than or equal to current, this attribute doesn't contribute to cost
                        // console.log(`[calculateAllUpgrades] BBGM -   ${attrKey} already at or above target (${currentAttrRating} >= ${targetAttrRating}).`); // Reduced logging
                        continue;
                    }
                    const costFunction = appSpecificData.upgradeCostPerAttribute[attrKey];
                    if (typeof costFunction !== 'function') {
                        console.error(`[calculateAllUpgrades] BBGM - Cost function for attribute ${attrKey} is not defined.`);
                        if (categoryElements.costDisplay) categoryElements.costDisplay.innerText = "Error"; // This will set it for the category
                        categoryTotalCost = NaN; // Indicate error for the category
                        break;
                    }
                    for (let i = currentAttrRating + 1; i <= targetAttrRating; i++) {
                        const stepCost = costFunction(i);
                        categoryTotalCost += stepCost;
                        // console.log(`[calculateAllUpgrades] BBGM -   ${attrKey} (level ${i}): Step cost: ${stepCost}`); // Reduced logging
                    }
                }
                if (isNaN(categoryTotalCost)) { // Handle NaN from BBGM error
                    if (categoryElements.costDisplay) categoryElements.costDisplay.innerText = "Error";
                    continue;
                }
                if (categoryElements.costDisplay) categoryElements.costDisplay.innerText = Math.round(categoryTotalCost);
                totalCost += categoryTotalCost;
                // console.log(`[calculateAllUpgrades] BBGM - ${category.key} total cost: ${Math.round(totalCost)}`); // Reduced logging
            }
      }

      const summary = elements.upgradeSummary;
      if (summary) {
        summary.innerHTML = `Total Cost: ${Math.round(totalCost)}<br>Points After: ${bank - Math.round(totalCost)}`;
        summary.dataset.totalCost = Math.round(totalCost);
        console.log(`[calculateAllUpgrades] Overall Summary - Total Upgrade Cost: ${Math.round(totalCost)}, Points After: ${bank - Math.round(totalCost)}`);
      }
      saveCurrentAppData(appId);
    }


    function confirmUpgrade(appId) {
      console.log(`[confirmUpgrade] Called for appId: ${appId}`);
      const elements = getAppElements(appId);
      let cost = parseInt(elements.upgradeSummary?.dataset.totalCost || "0");
      
      const bankInput = elements.manualTotalPoints;
      let currentPoints = parseInt(bankInput?.value || '0') || 0;

      console.log(`[confirmUpgrade] Cost: ${cost}, Current Points: ${currentPoints}`);

      if (cost > currentPoints) {
        alert("Not enough points for this upgrade!"); 
        console.warn(`[confirmUpgrade] Insufficient points. Aborting upgrade.`);
        return;
      }

      bankInput.value = currentPoints - cost;
      updatePointsBankDisplay(appId);
      console.log(`[confirmUpgrade] Points deducted. New bank: ${bankInput.value}`);

      if (appId === 'bbgm' && currentBBGMPlayerJson) {
          console.log(`[confirmUpgrade] Applying BBGM player attribute upgrades.`);
          // IMPORTANT: Apply upgrades to the specific ratings object within the array
          // Find the ratings object for the currently selected season
          const selectedSeason = parseInt(elements.seasonSelect.value);
          const playerRatingsEntry = currentBBGMPlayerJson.players[0].ratings.find(r => r.season === selectedSeason);

          if (playerRatingsEntry) {
              const playerRatings = playerRatingsEntry; // This is the object to modify
              const appSpecificData = appData[appId];

              appSpecificData.upgradeCategories.forEach(category => {
                  const categoryElements = elements.getUpgradeElements(category.key);
                  const useCategory = categoryElements.use ? categoryElements.use.checked : false;

                  if (!useCategory) { // If category is not checked, skip applying upgrades for its attributes
                      return;
                  }

                  category.attributes.forEach(attrKey => {
                      const currentAttrRating = playerRatings[attrKey] || 0;
                      const targetAttrRating = parseInt(bbgmAttributeTargets[attrKey] || currentAttrRating);

                      if (targetAttrRating > currentAttrRating) { // Only upgrade if target is higher
                          playerRatings[attrKey] = Math.min(100, Math.max(0, targetAttrRating)); // Ensure rating stays within 0-100
                          // console.log(`[confirmUpgrade]   Attribute ${attrKey} set to ${playerRatings[attrKey]}.`); // Reduced logging
                      }
                  });
              });
              // After modifying the ratings, update currentBBGMSeasonRatings to reflect changes
              currentBBGMSeasonRatings = playerRatings;
              updateBBGMCurrentRatingsUI(); // Refresh UI and recalculate costs based on new ratings
              showMessage("Upgrade successful! Player ratings have been updated internally.", 'success');
          } else {
              console.error(`[confirmUpgrade] Could not find ratings entry for season ${selectedSeason} to apply upgrades.`);
              showMessage("Error: Could not apply upgrades to the selected season's ratings.", 'danger');
          }
      } else if (appId === 'bbgm' && !currentBBGMPlayerJson) {
          // If no player is loaded, but user confirmed upgrade, just deduct points and reset targets
          // This assumes they were just testing costs or doing a manual simulation
          showMessage("Upgrade successful! Points deducted. (No player imported, so no ratings updated).", 'success');
          // Reset bbgmAttributeTargets to 0 for all attributes after "confirm" if no player is loaded
          for (const attrKey in bbgmAttributeTargets) {
              bbgmAttributeTargets[attrKey] = 0;
          }
          // Update UI to reflect reset
          appData.bbgm.upgradeCategories.forEach(category => {
              updateBBGMCurrentAndTargetInputs(category.key);
          });
      } else {
          showMessage("Upgrade successful!", 'success');
      }
      calculateAllUpgrades(appId); // Recalculate costs to reflect new current ratings
      saveCurrentAppData(appId); // Save state after upgrade
    }


    // --- UI & EVENT HANDLING ---

    // Global transition duration to match CSS
    const TRANSITION_DURATION = 500; // 0.5s in milliseconds

    function attachEventListeners() {
        console.log("[attachEventListeners] Attaching global event listeners.");
        // Main menu buttons
        document.getElementById('showNba2kBtn').addEventListener('click', () => showApp('nba2k'));
        document.getElementById('showBbgmBtn').addEventListener('click', () => showApp('bbgm'));
        document.getElementById('openBbgmBtn').addEventListener('click', () => { console.log("[openBbgmBtn] Opening BBGM website."); window.open("https://play.basketball-gm.com/", "_blank"); });
        document.getElementById('showGlobalSettingsBtn').addEventListener('click', () => showApp('globalSettings')); // New button
        document.getElementById('showManualBtn').addEventListener('click', () => showApp('manual'));
        document.getElementById('fileInput').addEventListener('change', handleMainMenuFileImport);
        document.querySelectorAll('.backToMenuBtn').forEach(btn => btn.addEventListener('click', backToMenu));
        document.getElementById('showTutorialOnStartup').addEventListener('change', (e) => {
            console.log(`[showTutorialOnStartup] Checkbox changed to: ${e.target.checked}`);
            saveToLocal('showTutorialOnStartup', e.target.checked);
        });
        document.getElementById('toggleDarkModeBtn').addEventListener('click', toggleDarkMode); // Moved to global settings

        ['nba2k', 'bbgm'].forEach(appId => {
            // console.log(`[attachEventListeners] Attaching listeners for ${appId} app.`); // Reduced logging
            const elements = getAppElements(appId);
            
            // Export/Import buttons
            document.getElementById(`${appId}_exportBtn`).addEventListener('click', () => exportData(appId));
            document.getElementById(`${appId}_importBtn`).addEventListener('click', () => {
                console.log(`[${appId}_importBtn] Triggering file input click.`);
                document.getElementById(`${appId}_importFile`).click();
            });
            document.getElementById(`${appId}_importFile`).addEventListener('change', (event) => importData(event, appId));
            
            // Multiplier info toggle
            document.getElementById(`${appId}_toggleMultiplierInfoBtn`).addEventListener('click', () => toggleMultiplierInfo(appId));
            
            // Upgrade calculations
            document.getElementById(`${appId}_calculateAllUpgradesBtn`).addEventListener('click', () => calculateAllUpgrades(appId));
            document.getElementById(`${appId}_confirmUpgradeBtn`).addEventListener('click', () => confirmUpgrade(appId));
            
            // Points bank manual input
            if (elements.manualTotalPoints) elements.manualTotalPoints.addEventListener('input', () => updatePointsBankDisplay(appId));
            
            // Game stats form inputs
            if (elements.statsForm) {
                Array.from(elements.statsForm.elements).forEach(input => {
                    if ((input.type === 'number' || input.type === 'text') && input.name) { // Handle text type too
                        input.addEventListener('input', () => {
                            // console.log(`[${appId}_statsForm] Input changed for ${input.name}. Recalculating points.`); // Reduced logging
                            calculatePointsEarned(appId);
                        });
                    }
                });
                elements.statsForm.addEventListener('submit', (e) => {
                    e.preventDefault(); // Prevent default form submission
                    console.log(`[${appId}_statsForm] Submit button clicked. Recalculating points.`);
                    if (appId === 'bbgm') { // BBGM specific multiplier warning
                        const winsCategory = elements.winsCategory?.value || '';
                        const playoffPerformance = elements.playoffPerformance?.value || '';
                        if ((winsCategory === "" || playoffPerformance === "") && !bbgmMultiplierWarningShown) {
                            showMessage("Please select values for 'Regular Season Wins' and 'Playoff Performance' multipliers for extra points. Click 'Calculate Points Earned' again to proceed without multipliers.", 'warning');
                            bbgmMultiplierWarningShown = true;
                            return;
                        }
                    }
                    calculatePointsEarned(appId);
                    bbgmMultiplierWarningShown = false; // Reset after successful calculation
                });
            }
            
            // Add points to bank button
            if (elements.addPointsToBankBtn) elements.addPointsToBankBtn.addEventListener('click', () => addPointsToBank(appId));

            // Attribute upgrade inputs and checkboxes (NBA2K specific)
            if (appId === 'nba2k') {
                appData[appId].upgradeCategories.forEach(category => {
                    const catElements = elements.getUpgradeElements(category.key);
                    [catElements.use, catElements.current, catElements.target].forEach(el => {
                        if (el) el.addEventListener('change', () => {
                            // console.log(`[${appId}_upgrade] Input changed for ${category.key} (${el.id}). Recalculating upgrades.`); // Reduced logging
                            calculateAllUpgrades(appId);
                        });
                    });
                });
            }


            // NBA2K specific multiplier listeners
            if (appId === 'nba2k') {
                if (elements.gameResult) elements.gameResult.addEventListener('change', () => {
                    // console.log(`[nba2k_gameResult] Changed to ${elements.gameResult.value}. Toggling OT box and recalculating.`); // Reduced logging
                    toggleOTBox(appId);
                    calculatePointsEarned(appId);
                });
                if (elements.otCount) elements.otCount.addEventListener('change', () => {
                    // console.log(`[nba2k_otCount] Changed to ${elements.otCount.value}. Recalculating points.`); // Reduced logging
                    calculatePointsEarned(appId);
                });
                if (elements.opponentType) elements.opponentType.addEventListener('change', () => {
                    // console.log(`[nba2k_opponentType] Changed to ${elements.opponentType.value}. Recalculating points.`); // Reduced logging
                    calculatePointsEarned(appId);
                });
                if (elements.teamHistory) elements.teamHistory.addEventListener('change', () => {
                    // console.log(`[nba2k_teamHistory] Changed to ${elements.teamHistory.value}. Recalculating points.`); // Reduced logging
                    calculatePointsEarned(appId);
                });
                if (elements.priceMultiplier) elements.priceMultiplier.addEventListener('change', () => {
                    // console.log(`[nba2k_priceMultiplier] Changed to ${elements.priceMultiplier.value}. Recalculating upgrades.`); // Reduced logging
                    calculateAllUpgrades(appId);
                });
            } else { // BBGM specific listeners
                document.getElementById('bbgm_playerImportBtn').addEventListener('click', () => {
                    console.log(`[bbgm_playerImportBtn] Triggering player file input click.`);
                    document.getElementById('bbgm_playerImportFile').click();
                });
                document.getElementById('bbgm_playerImportFile').addEventListener('change', handleBBGMPlayerFile); // This one is handled directly by its own function
                document.getElementById('bbgm_exportModifiedPlayerBtn').addEventListener('click', exportModifiedBBGMPlayer);
                // Removed event listener for bbgm_showRatingsBtn as it's no longer a popup
                document.getElementById('bbgm_generateReportBtn').addEventListener('click', generateScoutingReport);
                document.getElementById('bbgm_generateRandomPlayerBtn').addEventListener('click', generateRandomBBGMPlayer); // New button for random player

                // BBGM Quick Select Attribute dropdown
                if (elements.quickSelectAttribute) {
                    elements.quickSelectAttribute.addEventListener('change', (e) => {
                        const selectedAttrKey = e.target.value;
                        if (selectedAttrKey) {
                            // Find the category this attribute belongs to
                            const category = appData.bbgm.upgradeCategories.find(cat => cat.attributes.includes(selectedAttrKey));
                            if (category) {
                                const categoryElements = elements.getUpgradeElements(category.key);
                                if (categoryElements.select) {
                                    categoryElements.select.value = selectedAttrKey; // Set the category dropdown
                                    // Manually trigger change to update current/target inputs
                                    categoryElements.select.dispatchEvent(new Event('change'));
                                }
                            }
                            // Call updateBBGMCurrentAndTargetInputs for the specific category of the selected attribute
                            if (category) {
                                updateBBGMCurrentAndTargetInputs(category.key);
                            }

                            const targetInput = document.getElementById(`bbgm_target${category.key.charAt(0).toUpperCase() + category.key.slice(1)}Attribute`);
                            if (targetInput) {
                                targetInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                targetInput.focus();
                                const parentDiv = targetInput.closest('.bbgm-attribute-group');
                                if (parentDiv) {
                                    parentDiv.style.transition = 'box-shadow 0.3s ease-in-out';
                                    parentDiv.style.boxShadow = '0 0 15px 5px var(--highlight)';
                                    setTimeout(() => {
                                        parentDiv.style.boxShadow = '';
                                    }, 1000);
                                }
                            }
                        }
                    });
                }

                // BBGM Season Select and Add Points button
                if (elements.seasonSelect) elements.seasonSelect.addEventListener('change', calculatePointsFromSelectedSeason);
                if (elements.addSeasonPointsToBankBtn) elements.addSeasonPointsToBankBtn.addEventListener('click', addSeasonPointsToBank);

                // Season Stats Tabs
                if (elements.showRegularSeasonStatsBtn) elements.showRegularSeasonStatsBtn.addEventListener('click', () => {
                    currentStatsView = 'regularSeason';
                    updateBBGMSeasonStatsPanel();
                    saveCurrentAppData('bbgm');
                });
                if (elements.showPlayoffStatsBtn) elements.showPlayoffStatsBtn.addEventListener('click', () => {
                    currentStatsView = 'playoffs';
                    updateBBGMSeasonStatsPanel();
                    saveCurrentAppData('bbgm');
                });


                if (elements.winsCategory) elements.winsCategory.addEventListener('change', () => {
                    // console.log(`[bbgm_winsCategory] Changed to ${elements.winsCategory.value}. Recalculating points.`); // Reduced logging
                    calculatePointsFromSelectedSeason(); // Update season points when multiplier changes
                });
                if (elements.playoffPerformance) elements.playoffPerformance.addEventListener('change', () => {
                    // console.log(`[bbgm_playoffPerformance] Changed to ${elements.playoffPerformance.value}. Recalculating points.`); // Reduced logging
                    calculatePointsFromSelectedSeason(); // Update season points when multiplier changes
                });

                // BBGM Category Checkbox and Individual Attribute Input Listeners
                appData.bbgm.upgradeCategories.forEach(category => {
                    const categoryElements = elements.getUpgradeElements(category.key);
                    if (categoryElements.use) { // Listener for the new category checkbox
                        categoryElements.use.addEventListener('change', () => {
                            calculateAllUpgrades('bbgm');
                            // Optionally disable/enable target input for the selected attribute within this category
                            const targetInput = categoryElements.target;
                            if (targetInput) {
                                targetInput.disabled = !categoryElements.use.checked;
                                if (!categoryElements.use.checked) {
                                    // If category is excluded, reset its target to current for calculation purposes
                                    const selectedAttr = categoryElements.select.value;
                                    if (selectedAttr && currentBBGMPlayerJson) { // Only reset if a player is loaded
                                        // If no player is loaded, let the user manually control 'current'
                                        if (currentBBGMSeasonRatings && currentBBGMSeasonRatings[selectedAttr] !== undefined) {
                                            bbgmAttributeTargets[selectedAttr] = currentBBGMSeasonRatings[selectedAttr];
                                        } else {
                                            bbgmAttributeTargets[selectedAttr] = 0; // Default to 0 if no player and not previously set
                                        }
                                        updateBBGMCurrentAndTargetInputs(category.key); // Refresh inputs
                                    }
                                }
                            }
                        });
                    }
                    // Existing listeners for select and target input within this category
                    if (categoryElements.select) {
                        categoryElements.select.addEventListener('change', () => {
                            updateBBGMCurrentAndTargetInputs(category.key);
                            calculateAllUpgrades('bbgm');
                        });
                    }
                    if (categoryElements.target) {
                        // Use 'blur' and 'keydown' for Enter key to trigger validation
                        categoryElements.target.addEventListener('blur', () => {
                            const selectedAttr = categoryElements.select.value;
                            if (selectedAttr) {
                                const currentVal = parseInt(categoryElements.current.value) || 0;
                                let targetVal = parseInt(categoryElements.target.value) || 0;
                                
                                // Cap target value at 100
                                if (targetVal > 100) {
                                    targetVal = 100;
                                    categoryElements.target.value = 100; // Update the input field
                                    showMessage("Target rating cannot exceed 100.", 'warning');
                                }

                                // Validation for target < current
                                if (targetVal < currentVal) {
                                    showMessage(`Target rating (${targetVal}) cannot be less than current rating (${currentVal}).`, 'warning');
                                    // Do NOT revert, allow user to keep the value, but warn
                                }

                                bbgmAttributeTargets[selectedAttr] = targetVal;
                                calculateAllUpgrades('bbgm');
                            }
                        });
                        categoryElements.target.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                categoryElements.target.blur(); // Trigger blur event to run validation
                            }
                        });
                    }
                    // Listener for current attribute input (only if no player is loaded)
                    if (categoryElements.current) {
                        categoryElements.current.addEventListener('input', () => {
                            if (!currentBBGMPlayerJson) { // Only allow manual input if no player is loaded
                                const selectedAttr = categoryElements.select.value;
                                if (selectedAttr) {
                                    let currentVal = parseInt(categoryElements.current.value) || 0;
                                    if (currentVal < 0) {
                                        currentVal = 0;
                                        categoryElements.current.value = 0;
                                        showMessage("Current rating cannot be less than 0.", 'warning');
                                    }
                                    if (currentVal > 100) {
                                        currentVal = 100;
                                        categoryElements.current.value = 100;
                                        showMessage("Current rating cannot exceed 100.", 'warning');
                                    }
                                    bbgmAttributeTargets[selectedAttr] = currentVal; // Store the manually set "current" as a target
                                    // Also update the target to be at least the current value
                                    let targetVal = parseInt(categoryElements.target.value) || 0;
                                    if (targetVal < currentVal) {
                                        categoryElements.target.value = currentVal;
                                        bbgmAttributeTargets[selectedAttr] = currentVal; // Update target in bbgmAttributeTargets
                                    }
                                    calculateAllUpgrades('bbgm');
                                }
                            }
                        });
                    }
                });
            }
        });
        console.log("[attachEventListeners] All event listeners attached.");
    }

    // New function to display messages to the user
    function showMessage(message, type = 'info') {
        const messageDisplay = document.getElementById('messageDisplay');
        const messageContent = document.getElementById('messageContent');
        messageContent.innerHTML = message;
        messageDisplay.className = `show ${type}`; // Add type for potential styling
        console.log(`[showMessage] Displaying message: Type=${type}, Content=${message}`);
    }

    function hideMessage() {
        const messageDisplay = document.getElementById('messageDisplay');
        messageDisplay.classList.remove('show');
        console.log("[hideMessage] Message display hidden.");
    }

    function showApp(appId) {
      console.log(`[showApp] Displaying app section: ${appId}`);
      const currentActiveApp = document.querySelector('.app-section.active');
      const mainMenu = document.getElementById('mainMenu');
      const targetApp = document.getElementById(appId + 'App');
      
      // Initialize elements here, so it's always defined
      let elements; 
      if (appId === 'nba2k' || appId === 'bbgm') {
          elements = getAppElements(appId);
      } else {
          // For global settings or manual, elements might not be needed or are simpler
          elements = {}; // Provide an empty object or specific elements if needed
      }

      if (currentActiveApp) {
          currentActiveApp.classList.remove('active');
          // Wait for the transition to finish before setting display: none
          setTimeout(() => {
              currentActiveApp.style.display = 'none';
          }, TRANSITION_DURATION);
      } else if (mainMenu.classList.contains('active')) {
          mainMenu.classList.remove('active');
          setTimeout(() => {
              mainMenu.style.display = 'none';
          }, TRANSITION_DURATION);
      }

      if (targetApp) {
          targetApp.style.display = 'block'; // Make it display block immediately
          // Force reflow to ensure display:block is applied before active class
          void targetApp.offsetWidth;
          targetApp.classList.add('active');
          saveToLocal('activeApp', appId);

          const appDataFromLocal = loadFromLocal(`data_${appId}`);
          if (appDataFromLocal) {
              loadDataIntoApp(appDataFromLocal, appId);
          }
          
          // Specific initializations for each app
          if (appId === 'nba2k') toggleOTBox(appId);
          if (appId === 'bbgm') {
              createBBGMIndividualAttributeInputs(); // Ensure inputs are created when BBGM app is shown
              populateBBGMAttributeQuickSelect(); // Populate quick select dropdown
              // If no player is currently loaded, load the template player
              if (!currentBBGMPlayerJson) {
                  console.log("[showApp] No BBGM player loaded, initializing with template player.");
                  currentBBGMPlayerJson = JSON.parse(JSON.stringify(defaultBBGMPlayer)); // Deep copy to avoid modifying original template
                  currentBBGMPlayerId = defaultBBGMPlayer.players[0].pid; // Set ID for default player
                  
                  // Initialize bbgmAttributeTargets with default player's current ratings
                  currentBBGMSeasonRatings = getLatestPlayerRatings(currentBBGMPlayerJson.players[0]);
                  for (const attrKey in currentBBGMSeasonRatings) { // Iterate through current season ratings
                      if (appData.bbgm.attributeLabels.hasOwnProperty(attrKey)) { // Only include valid attributes
                          bbgmAttributeTargets[attrKey] = currentBBGMSeasonRatings[attrKey] || 0;
                      }
                  }
                  saveCurrentAppData('bbgm'); // Save the template player and initial targets to local storage
              }
              populateBBGMSeasonSelect(); // Populate and select latest season first
              // Now get ratings for the selected season (which is the latest by default after populate)
              const selectedSeason = parseInt(elements.seasonSelect.value);
              currentBBGMSeasonRatings = getRatingsForSeason(selectedSeason);

              updateBBGMPlayerInfoDisplay(); // Update player name and overall
              updateBBGMCurrentRatingsUI(); // Ensure BBGM current ratings are updated on app switch
              calculateAllUpgrades('bbgm'); // Calculate initial cost for selected attribute
              calculatePointsFromSelectedSeason(); // Calculate points from selected season
              updateBBGMSeasonStatsPanel(); // Update the new season stats panel

              // Force New Player Import checkbox behavior on app load
              const forceNewPlayerImportCheckbox = elements.forceNewPlayerImport;
              if (forceNewPlayerImportCheckbox) {
                  // Only set to true if NO player is currently loaded
                  if (!currentBBGMPlayerJson || currentBBGMPlayerId === "") {
                      forceNewPlayerImportCheckbox.checked = true;
                      console.log("Force New Player Import set to true as no player is loaded.");
                  } else {
                      forceNewPlayerImportCheckbox.checked = false; // Ensure it's off if a player is loaded
                      console.log("Force New Player Import set to false as a player is already loaded.");
                  }
              }

          }
      } else {
          console.error(`[showApp] Target app section with ID '${appId}App' not found.`);
      }
    }

    function backToMenu() {
      console.log("[backToMenu] Returning to main menu.");
      const currentActiveApp = document.querySelector('.app-section.active');
      const mainMenu = document.getElementById('mainMenu');

      if (currentActiveApp) {
          currentActiveApp.classList.remove('active');
          setTimeout(() => {
              currentActiveApp.style.display = 'none';
              mainMenu.style.display = 'flex'; // Main menu uses flex for centering
              // Force reflow
              void mainMenu.offsetWidth;
              mainMenu.classList.add('active');
          }, TRANSITION_DURATION);
      } else {
          // If somehow no app is active, just ensure main menu is shown
          mainMenu.style.display = 'flex';
          void mainMenu.offsetWidth;
          mainMenu.classList.add('active');
      }
      localStorage.removeItem('mycareer_activeApp');
    }

    function toggleDarkMode() {
      console.log("[toggleDarkMode] Toggling dark/light mode.");
      document.body.classList.toggle('light-mode');
      saveToLocal('darkMode', document.body.classList.contains('light-mode'));
    }

    function toggleOTBox(appId) {
      // console.log(`[toggleOTBox] Called for appId: ${appId}`); // Reduced logging
      if (appId !== 'nba2k') return;
      const elements = getAppElements(appId);
      if (elements.otCountBox && elements.gameResult) {
        const isOTWin = elements.gameResult.value === "otwin";
        elements.otCountBox.style.display = isOTWin ? "block" : "none"; // Only show if OT win
        // console.log(`[toggleOTBox] OT Count Box display set to: ${elements.otCountBox.style.display}`); // Reduced logging
      } else if (elements.otCountBox) {
        elements.otCountBox.style.display = "none"; // Hide otherwise
      }
    }

    function toggleMultiplierInfo(appId) {
      console.log(`[toggleMultiplierInfo] Called for appId: ${appId}`);
      const info = document.getElementById(`${appId}_multiplierInfo`);
      if (info) {
        info.style.display = info.style.display === "none" ? "block" : "none";
        console.log(`[toggleMultiplierInfo] Multiplier info display set to: ${info.style.display}`);
      }
    }

    function updatePointsBankDisplay(appId) {
      // console.log(`[updatePointsBankDisplay] Called for appId: ${appId}`); // Reduced logging
      const elements = getAppElements(appId);
      if (elements.pointsBankDisplay && elements.manualTotalPoints) {
        const newDisplayValue = parseInt(elements.manualTotalPoints.value) || 0;
        elements.pointsBankDisplay.innerText = newDisplayValue;
        // console.log(`[updatePointsBankDisplay] Points bank display updated to: ${newDisplayValue}`); // Reduced logging
      }
      saveCurrentAppData(appId);
    }
    
    // --- BBGM-SPECIFIC FUNCTIONS ---

    // Function to get the latest ratings object from the player's ratings array
    function getLatestPlayerRatings(player) {
        if (!player || !player.ratings || player.ratings.length === 0) {
            return null;
        }
        // Find the rating entry with the highest season number
        const latestRatingEntry = player.ratings.reduce((latest, current) => {
            return (current.season || 0) > (latest.season || 0) ? current : latest;
        }, player.ratings[0]); // Start with the first element as initial latest

        // Return a copy of the ratings within that entry, excluding 'season' and 'skills'
        const { season, skills, ...actualRatings } = latestRatingEntry;
        return actualRatings;
    }

    // Function to get ratings for a specific season
    function getRatingsForSeason(season) {
        if (!currentBBGMPlayerJson || !currentBBGMPlayerJson.players || !currentBBGMPlayerJson.players[0].ratings) {
            return null;
        }
        const player = currentBBGMPlayerJson.players[0];
        const ratingsEntry = player.ratings.find(r => r.season === season);
        if (ratingsEntry) {
            const { season, skills, ...actualRatings } = ratingsEntry; // Exclude season and skills
            return actualRatings;
        }
        return null;
    }

    // Function to update player name, position, overall, and potential display
    function updateBBGMPlayerInfoDisplay() {
        const elements = getAppElements('bbgm');
        if (currentBBGMPlayerJson && currentBBGMPlayerJson.players && currentBBGMPlayerJson.players[0]) {
            const player = currentBBGMPlayerJson.players[0];
            
            // Get OVR, POS, POT from the currently selected season's ratings
            const selectedSeason = parseInt(elements.seasonSelect.value);
            const currentSeasonRatings = getRatingsForSeason(selectedSeason);

            elements.playerNameDisplay.innerText = `${player.firstName || ''} ${player.lastName || ''}`.trim() || 'N/A';
            elements.playerAgeDisplay.innerText = player.age || 'N/A'; // Display age
            elements.playerPosDisplay.innerText = currentSeasonRatings?.pos || player.pos || 'N/A';
            elements.playerOvrDisplay.innerText = currentSeasonRatings?.ovr || player.ovr || 'N/A';
            elements.playerPotDisplay.innerText = currentSeasonRatings?.pot || player.pot || 'N/A';
        } else {
            elements.playerNameDisplay.innerText = 'N/A';
            elements.playerAgeDisplay.innerText = 'N/A';
            elements.playerPosDisplay.innerText = 'N/A';
            elements.playerOvrDisplay.innerText = 'N/A';
            elements.playerPotDisplay.innerText = 'N/A';
        }
    }

    // Function to create individual attribute input fields for BBGM
    function createBBGMIndividualAttributeInputs() {
        // console.log("[createBBGMIndividualAttributeInputs] Called."); // Reduced logging
        const appSpecificData = appData.bbgm;

        appSpecificData.upgradeCategories.forEach(category => {
            const categoryElements = getAppElements('bbgm').getUpgradeElements(category.key);

            // Populate category select dropdown
            if (categoryElements.select) {
                categoryElements.select.innerHTML = ''; // Clear existing options
                category.attributes.forEach(attrKey => {
                    const option = document.createElement('option');
                    option.value = attrKey;
                    option.innerText = appSpecificData.attributeLabels[attrKey] || attrKey.toUpperCase();
                    categoryElements.select.appendChild(option);
                });

                // Set initial selection if already stored, otherwise select the first attribute
                if (!categoryElements.select.value && category.attributes.length > 0) {
                    categoryElements.select.value = category.attributes[0];
                }
            }
            // console.log(`[createBBGMIndividualAttributeInputs] Inputs and listeners set for ${category.key}.`); // Reduced logging
        });
    }

    // Updates the current and target input fields for a specific BBGM category
    function updateBBGMCurrentAndTargetInputs(categoryKey) {
        // console.log(`[updateBBGMCurrentAndTargetInputs] Updating inputs for category: ${categoryKey}`); // Reduced logging
        const elements = getAppElements('bbgm');
        const categoryElements = elements.getUpgradeElements(categoryKey);
        
        const selectedAttr = categoryElements.select.value;
        if (!selectedAttr) {
            categoryElements.current.value = 0;
            categoryElements.target.value = 0;
            categoryElements.current.readOnly = false; // Always editable if no attribute selected
            categoryElements.current.style.backgroundColor = ''; // Reset background
            return;
        }

        let currentRating;
        if (currentBBGMPlayerJson && currentBBGMSeasonRatings) {
            currentRating = currentBBGMSeasonRatings[selectedAttr] !== undefined ? currentBBGMSeasonRatings[selectedAttr] : 0;
            categoryElements.current.readOnly = true; // Read-only if player is loaded
            categoryElements.current.style.backgroundColor = 'var(--bg)'; // Visually differentiate read-only
        } else {
            // If no player is loaded, allow manual input for "Current"
            currentRating = parseInt(categoryElements.current.value) || 0; // Use current value from input
            categoryElements.current.readOnly = false; // Editable if no player
            categoryElements.current.style.backgroundColor = ''; // Reset background
        }
        
        // Use the stored target rating, or default to current if not set
        let targetRating = bbgmAttributeTargets[selectedAttr] !== undefined ? bbgmAttributeTargets[selectedAttr] : currentRating;

        // Ensure target is never less than current, and never more than 100
        targetRating = Math.min(100, Math.max(currentRating, targetRating));

        categoryElements.current.value = currentRating;
        categoryElements.target.value = targetRating;
        // Also update the disabled state of the target input based on the category checkbox
        if (categoryElements.use) {
            categoryElements.target.disabled = !categoryElements.use.checked;
        }
        // console.log(`[updateBBGMCurrentAndTargetInputs] ${selectedAttr}: Current=${currentRating}, Target=${targetRating}`); // Reduced logging
    }


    // Function to populate the quick select dropdown for BBGM attributes
    function populateBBGMAttributeQuickSelect() {
        // console.log("[populateBBGMAttributeQuickSelect] Called."); // Reduced logging
        const selectElement = document.getElementById('bbgm_quickSelectAttribute');
        if (!selectElement) {
            console.warn("BBGM quick select attribute dropdown not found.");
            return;
        }
        selectElement.innerHTML = '<option value="">- Jump to Attribute -</option>'; // Clear existing options and add default

        const allAttributes = {};
        appData.bbgm.upgradeCategories.forEach(category => {
            category.attributes.forEach(attrKey => {
                allAttributes[attrKey] = appData.bbgm.attributeLabels[attrKey] || attrKey.toUpperCase();
            });
        });

        // Sort attributes alphabetically by display label
        const sortedAttrKeys = Object.keys(allAttributes).sort((a, b) => allAttributes[a].localeCompare(allAttributes[b]));

        sortedAttrKeys.forEach(attrKey => {
            const option = document.createElement('option');
            option.value = attrKey;
            option.innerText = allAttributes[attrKey];
            selectElement.appendChild(option);
        });
        // console.log("[populateBBGMAttributeQuickSelect] BBGM quick select dropdown populated."); // Reduced logging
    }
    
    async function handleBBGMPlayerFile(event) {
        console.log("[handleBBGMPlayerFile] Called.");
        const file = event.target.files[0];
        if (!file) {
            console.log("[handleBBGMPlayerFile] No file selected.");
            return;
        }
        const reader = new FileReader();
        reader.onload = async e => {
            console.log(`[handleBBGMPlayerFile] File read complete for ${file.name}.`);
            try {
                const importedJson = JSON.parse(e.target.result);
                console.log("[handleBBGMPlayerFile] Imported JSON parsed.");

                // Ensure the 'ratings' property is an array as per the user's JSON example
                if (!importedJson.players?.[0]?.stats || !Array.isArray(importedJson.players?.[0]?.ratings)) {
                    showMessage("Invalid BBGM player file: Missing stats or 'ratings' is not an array.", 'danger'); 
                    console.error("[handleBBGMPlayerFile] Invalid player file structure: Missing stats or ratings array.");
                    event.target.value = ''; // Clear file input
                    return;
                }

                const incomingPlayerId = importedJson.players[0].pid || `${importedJson.players[0].firstName || ''}_${importedJson.players[0].lastName || ''}_${importedJson.players[0].age || ''}_${importedJson.players[0].pos || ''}`;
                const elements = getAppElements('bbgm');
                const forceNewPlayerImportCheckbox = elements.forceNewPlayerImport;

                // Check if a player is already loaded AND the IDs mismatch AND force checkbox is NOT checked
                if (currentBBGMPlayerId !== "" && currentBBGMPlayerId !== incomingPlayerId) {
                    if (!forceNewPlayerImportCheckbox.checked) {
                        showMessage(`Player ID mismatch! Currently loaded: ${currentBBGMPlayerJson?.players[0]?.firstName || ''} ${currentBBGMPlayerJson?.players[0].lastName || ''} (ID: ${currentBBGMPlayerId}). Imported: ${importedJson.players[0].firstName} ${importedJson.players[0].lastName} (ID: ${incomingPlayerId}). Check 'Force New Player Import' to continue.`, 'danger');
                        event.target.value = ''; // Clear file input
                        return;
                    } else {
                        showMessage(`Warning: Importing a new player (${importedJson.players[0].firstName || ''} ${importedJson.players[0].lastName || ''}) and overwriting current player.`, 'warning');
                    }
                }
                
                currentBBGMPlayerJson = importedJson;
                currentBBGMPlayerId = incomingPlayerId; // Update the current player ID

                // After setting currentBBGMPlayerJson, populate season select and then update player info
                populateBBGMSeasonSelect(); // Populate and select latest season first
                // Now get ratings for the selected season (which is the latest by default after populate)
                const selectedSeason = parseInt(elements.seasonSelect.value);
                currentBBGMSeasonRatings = getRatingsForSeason(selectedSeason);
                
                bbgmAttributeTargets = {};
                if (currentBBGMSeasonRatings) {
                    for (const attrKey in currentBBGMSeasonRatings) {
                        if (appData.bbgm.attributeLabels.hasOwnProperty(attrKey)) { // Only include valid attributes
                            bbgmAttributeTargets[attrKey] = currentBBGMSeasonRatings[attrKey] || 0;
                        }
                    }
                }
                // console.log("[handleBBGMPlayerFile] bbgmAttributeTargets initialized with latest player ratings:", bbgmAttributeTargets); // Reduced logging

                updateBBGMPlayerInfoDisplay(); // Update player name, OVR, POS, POT display based on selected season
                
                // Calculate and add points from awards (DO NOT ADD TO BANK AUTOMATICALLY)
                let awardsPoints = 0;
                if (currentBBGMPlayerJson.players[0].awards && Array.isArray(currentBBGMPlayerJson.players[0].awards)) {
                    currentBBGMPlayerJson.players[0].awards.forEach(award => {
                        if (AWARD_POINTS[award.name]) {
                            awardsPoints += AWARD_POINTS[award.name];
                            console.log(`[handleBBGMPlayerFile] Award "${award.name}" found, adding ${AWARD_POINTS[award.name]} points.`);
                        }
                    });
                }
                if (awardsPoints > 0) {
                    // Do NOT add to bank here. User will add manually from season points.
                    showMessage(`${awardsPoints} points were earned from career awards (not yet added to bank).`, 'info');
                }

                calculatePointsFromSelectedSeason(); // Calculate points for the initially selected (latest) season
                
                // The points are now added via the "Add Season Points to Bank" button, not automatically here.
                showMessage(`Imported player "${currentBBGMPlayerJson.players[0].firstName || ''} ${currentBBGMPlayerJson.players[0].lastName || ''}". Select a season to add points.`, 'success');
                
                updateBBGMCurrentRatingsUI(); // Always update UI after player import attempt
                calculateAllUpgrades('bbgm'); // Calculate cost for the newly loaded player's selected attribute
                saveCurrentAppData('bbgm'); // Save the updated player JSON and points
                updateBBGMSeasonStatsPanel(); // Update the new season stats panel

                // Turn off "Force New Player Import" after successful import
                elements.forceNewPlayerImport.checked = false;

            } catch (err) {
                showMessage("Error processing player file. Check console for details.", 'danger'); 
                console.error("[handleBBGMPlayerFile] Error:", err);
                currentBBGMPlayerJson = null; // Clear player if error
                currentBBGMPlayerId = ""; // Clear player ID if error
                bbgmAttributeTargets = {}; // Clear targets if error
                currentBBGMSeasonRatings = null; // Clear season ratings
                // Reset player name and overall display on error
                const elements = getAppElements('bbgm');
                if (elements.playerNameDisplay) elements.playerNameDisplay.innerText = 'N/A';
                if (elements.playerAgeDisplay) elements.playerAgeDisplay.innerText = 'N/A';
                if (elements.playerPosDisplay) elements.playerPosDisplay.innerText = 'N/A';
                if (elements.playerOvrDisplay) elements.playerOvrDisplay.innerText = 'N/A';
                if (elements.playerPotDisplay) elements.playerPotDisplay.innerText = 'N/A';
                if (elements.seasonSelect) elements.seasonSelect.innerHTML = '<option value="">- No Player Imported -</option>'; // Clear season select
                if (elements.seasonPointsEarned) elements.seasonPointsEarned.innerText = '0'; // Reset season points
                updateBBGMSeasonStatsPanel(); // Reset the season stats panel
            }
        };
        reader.onerror = (e) => {
            console.error(`[handleBBGMPlayerFile] FileReader error:`, e);
            showMessage("Error reading file. Please try again.", 'danger');
        };
        reader.readAsText(file);
        event.target.value = ''; // Clear the file input to allow re-importing the same file
        console.log(`[handleBBGMPlayerFile] FileReader initiated for ${file.name}.`);
    }

    // New function to populate the season selection dropdown
    function populateBBGMSeasonSelect(selectedSeasonToRestore = null) {
        const elements = getAppElements('bbgm');
        const seasonSelect = elements.seasonSelect;
        seasonSelect.innerHTML = ''; // Clear existing options

        if (!currentBBGMPlayerJson || !currentBBGMPlayerJson.players || !currentBBGMPlayerJson.players[0].stats) {
            seasonSelect.innerHTML = '<option value="">- No Player Imported -</option>';
            return;
        }

        const availableSeasons = new Set();
        // Collect seasons from both stats and ratings arrays
        currentBBGMPlayerJson.players[0].stats.forEach(s => {
            if (s.season) {
                availableSeasons.add(s.season);
            }
        });
        currentBBGMPlayerJson.players[0].ratings.forEach(r => {
            if (r.season) {
                availableSeasons.add(r.season);
            }
        });


        const sortedSeasons = Array.from(availableSeasons).sort((a, b) => b - a); // Sort descending to get latest first

        if (sortedSeasons.length === 0) {
            seasonSelect.innerHTML = '<option value="">- No Stats Available -</option>';
            return;
        }

        sortedSeasons.forEach(season => {
            const option = document.createElement('option');
            option.value = season;
            option.innerText = season;
            seasonSelect.appendChild(option);
        });

        // Select the latest season by default, or restore previously selected
        if (selectedSeasonToRestore && sortedSeasons.includes(parseInt(selectedSeasonToRestore))) {
            seasonSelect.value = selectedSeasonToRestore;
        } else {
            seasonSelect.value = sortedSeasons[0]; // Select the latest season
        }
        // Update previousSeason immediately after setting the value
        seasonSelect.dataset.previousSeason = seasonSelect.value;
    }

    // Function to get age nerf multiplier
    function getAgeNerfMultiplier(age) {
        if (age < 30) return 1.0;
        if (age >= 30 && age <= 32) return 0.9;
        if (age >= 33 && age <= 35) return 0.8;
        if (age >= 36) return 0.7; // More aggressive nerf for older players
        return 1.0;
    }

    // Function to get OVR nerf multiplier
    function getOvrNerfMultiplier(ovr) {
        if (ovr < 70) return 1.0;
        if (ovr >= 70 && ovr <= 79) return 0.9;
        if (ovr >= 80 && ovr <= 89) return 0.8;
        if (ovr >= 90) return 0.7; // More aggressive nerf for high OVR players
        return 1.0;
    }

    // New function to calculate points from the currently selected season
    function calculatePointsFromSelectedSeason() {
        const elements = getAppElements('bbgm');
        const seasonSelect = elements.seasonSelect;
        const newSelectedSeason = parseInt(seasonSelect.value);
        const oldSelectedSeason = parseInt(seasonSelect.dataset.previousSeason); // Get previous from data attribute

        if (!currentBBGMPlayerJson || !currentBBGMPlayerJson.players || !currentBBGMPlayerJson.players[0].stats || isNaN(newSelectedSeason)) {
            elements.seasonPointsEarned.innerText = '0';
            elements.seasonPointsEarned.dataset.points = '0';
            seasonSelect.dataset.previousSeason = newSelectedSeason; // Still update previous season
            // Also update current ratings UI to reflect "no player loaded" or similar
            currentBBGMSeasonRatings = null;
            updateBBGMCurrentRatingsUI();
            updateBBGMSeasonStatsPanel(); // Update the new season stats panel
            return;
        }

        let totalPoints = 0;
        let shouldCalculateSingleSeason = true; // Flag to determine if we calculate just the new season

        // Only show warnings if a previous season was actually selected AND it's different from the new one
        if (!isNaN(oldSelectedSeason) && oldSelectedSeason !== newSelectedSeason) {
            if (newSelectedSeason < oldSelectedSeason) {
                // Going back a year
                if (!confirm(`Are you sure you want to go back to season ${newSelectedSeason}? This will recalculate points based on that season's stats.`)) {
                    seasonSelect.value = oldSelectedSeason; // Revert selection in UI
                    // Re-trigger UI update for the reverted season
                    currentBBGMSeasonRatings = getRatingsForSeason(oldSelectedSeason);
                    updateBBGMCurrentRatingsUI();
                    // Crucially, update the dataset.previousSeason to the *reverted* value
                    seasonSelect.dataset.previousSeason = oldSelectedSeason;
                    updateBBGMSeasonStatsPanel(); // Update the new season stats panel
                    return; // Stop execution
                }
            } else if (newSelectedSeason > oldSelectedSeason + 1) {
                // Jumping forward multiple seasons
                const confirmMultiSeason = confirm(`You are jumping forward multiple seasons (from ${oldSelectedSeason} to ${newSelectedSeason}). Do you want to include stats from intermediate seasons (${oldSelectedSeason + 1} to ${newSelectedSeason}) for point calculation?`);
                
                if (confirmMultiSeason) {
                    for (let year = oldSelectedSeason + 1; year <= newSelectedSeason; year++) {
                        totalPoints += getPointsForSingleBBGMSeason(year);
                    }
                    shouldCalculateSingleSeason = false; // Multi-season points already calculated
                }
            }
        }
        
        // If shouldCalculateSingleSeason is still true (no multi-season calculation or if multi-year jump was declined), calculate for the single new season
        if (shouldCalculateSingleSeason) {
             totalPoints += getPointsForSingleBBGMSeason(newSelectedSeason);
        }
        
        elements.seasonPointsEarned.innerText = Math.round(totalPoints);
        elements.seasonPointsEarned.dataset.points = Math.round(totalPoints);
        seasonSelect.dataset.previousSeason = newSelectedSeason; // Update previous season for next comparison
        saveCurrentAppData('bbgm'); // Save selected season and calculated points

        // Update the current ratings display and upgrade inputs based on the newly selected season
        currentBBGMSeasonRatings = getRatingsForSeason(newSelectedSeason);
        updateBBGMCurrentRatingsUI();
        updateBBGMSeasonStatsPanel(); // Update the new season stats panel
    }

    // Helper function to get points for a single BBGM season
    function getPointsForSingleBBGMSeason(seasonYear) {
        let seasonPoints = 0;
        const player = currentBBGMPlayerJson.players[0];
        const seasonStats = player.stats.filter(s => s.season === seasonYear);
        
        let regularSeasonStats = seasonStats.find(s => !s.playoffs);
        let playoffStats = seasonStats.find(s => s.playoffs);

        // Get multipliers from UI
        const elements = getAppElements('bbgm');
        const winsCategory = elements.winsCategory?.value || '1';
        const playoffPerformance = elements.playoffPerformance?.value || '1';
        
        // Calculate the effective multiplier for each category, ensuring it's >= 1
        const winsMult = 1 + (parseFloat(winsCategory) - 1) * GLOBAL_MULTIPLIER_NERF;
        const playoffMult = 1 + (parseFloat(playoffPerformance) - 1) * GLOBAL_MULTIPLIER_NERF;
        
        const combinedMultiplier = winsMult * playoffMult;

        // Apply age and OVR nerfs
        const ageNerf = getAgeNerfMultiplier(player.age);
        const ovrNerf = getOvrNerfMultiplier(player.ovr); // Use player's overall, not season-specific ovr
        const totalNerf = ageNerf * ovrNerf;
        console.log(`[getPointsForSingleBBGMSeason] Season ${seasonYear}: Age Nerf: ${ageNerf}, OVR Nerf: ${ovrNerf}, Total Nerf: ${totalNerf}`);


        // Add points from regular season stats
        if (regularSeasonStats) {
            seasonPoints += calculatePointsFromBBGMStats(regularSeasonStats) * combinedMultiplier * totalNerf; // Apply all multipliers
            // Add points for games played (GP) in regular season
            seasonPoints += (regularSeasonStats.gp || 0) * POINTS_PER_GP * combinedMultiplier * totalNerf; // Apply all multipliers
        }
        // Add points from playoff stats with multiplier
        if (playoffStats) {
            seasonPoints += calculatePointsFromBBGMStats(playoffStats) * PLAYOFF_POINTS_MULTIPLIER * combinedMultiplier * totalNerf; // Apply all multipliers
            // Add points for games played (GP) in playoffs (also multiplied)
            seasonPoints += (playoffStats.gp || 0) * POINTS_PER_GP * PLAYOFF_POINTS_MULTIPLIER * combinedMultiplier * totalNerf; // Apply all multipliers
        }
        return seasonPoints;
    }

    // New function to add calculated season points to the bank
    function addSeasonPointsToBank() {
        const elements = getAppElements('bbgm');
        
        const winsCategory = elements.winsCategory?.value || '';
        const playoffPerformance = elements.playoffPerformance?.value || '';
        if ((winsCategory === "" || playoffPerformance === "") && !bbgmMultiplierWarningShown) {
            showMessage("Please select values for 'Regular Season Wins' and 'Playoff Performance' multipliers for extra points. Click 'Add Season Points to Bank' again to proceed without multipliers.", 'warning');
            bbgmMultiplierWarningShown = true; // Set flag to true after first warning
            return; // Stop execution on first warning
        }

        const pointsToAdd = parseInt(elements.seasonPointsEarned?.dataset.points || '0');
        const bankInput = elements.manualTotalPoints;

        if (!bankInput) {
            console.error(`[addSeasonPointsToBank] Points bank input not found for bbgm.`);
            return;
        }

        const currentBankValue = parseInt(bankInput.value) || 0;
        bankInput.value = currentBankValue + pointsToAdd;
        updatePointsBankDisplay('bbgm');
        showMessage(`${pointsToAdd} points from season ${elements.seasonSelect.value} added to your bank! Total: ${bankInput.value}`, 'success');
        saveCurrentAppData('bbgm');
        bbgmMultiplierWarningShown = false; // Reset after successful addition
    }


    function updateBBGMCurrentRatingsUI() {
        // console.log("[updateBBGMCurrentRatingsUI] Called."); // Reduced logging
        const elements = getAppElements('bbgm');

        if (!currentBBGMPlayerJson || !currentBBGMPlayerJson.players || !currentBBGMPlayerJson.players[0].ratings || !currentBBGMSeasonRatings) {
            // console.log("[updateBBGMCurrentRatingsUI] No BBGM player JSON or season ratings loaded. Resetting current ratings UI."); // Reduced logging
            // Reset UI if no player loaded
            appData.bbgm.upgradeCategories.forEach(category => {
                const categoryElements = elements.getUpgradeElements(category.key);
                if (categoryElements.current) {
                    categoryElements.current.value = 0;
                    categoryElements.current.readOnly = false; // Make editable
                    categoryElements.current.style.backgroundColor = ''; // Reset background
                }
                if (categoryElements.target) categoryElements.target.value = 0;
            });
            updateBBGMPlayerInfoDisplay(); // Reset player name/OVR/POS/POT display
            updateBBGMCurrentRatingsDisplayPanel(); // Reset current ratings panel
            return;
        }
        
        updateBBGMPlayerInfoDisplay(); // Update player name and overall
        // Update each category's displayed current/target inputs based on their selected attribute
        appData.bbgm.upgradeCategories.forEach(category => {
            updateBBGMCurrentAndTargetInputs(category.key);
        });
        updateBBGMCurrentRatingsDisplayPanel(); // Update the dedicated current ratings panel
        calculateAllUpgrades('bbgm'); // Recalculate costs with new current ratings
    }
    
    function calculatePointsFromBBGMStats(stats) {
        // console.log("[calculatePointsFromBBGMStats] Calculating points for stats:", stats); // Reduced logging
        const conversion = appData.bbgm.statConversionPoints;
        let total = 0;
        // Ensure stats are numbers, default to 0 if undefined or null
        const getStatValue = (stat) => stats[stat] !== undefined && stats[stat] !== null ? stats[stat] : 0;
        // let detailedLog = ``; // Removed detailedLog for this function

        // Handle 2-pointers and 3-pointers first
        const twoPointersMade = getStatValue('fg') - getStatValue('tp');
        const twoPtPoints = twoPointersMade * conversion.twoPointersMade;
        total += twoPtPoints;
        // detailedLog += `  2PT Made (${twoPointersMade}) * ${conversion.twoPointersMade} = ${twoPtPoints}\n`; // Removed

        const threePointersMade = getStatValue('tp');
        const threePtPoints = threePointersMade * conversion.threePointersMade;
        total += threePtPoints;
        // detailedLog += `  3PT Made (${threePointersMade}) * ${conversion.threePointersMade} = ${threePtPoints}\n`; // Removed

        // Iterate over other relevant stats for conversion
        const otherStats = ['ft', 'reb', 'ast', 'stl', 'blk', 'tov', 'pf', 'pm', 'min']; // Removed 'gp' as it's handled separately
        otherStats.forEach(key => {
            if (conversion.hasOwnProperty(key)) {
                const statValue = getStatValue(key);
                const convertedPoints = statValue * conversion[key];
                total += convertedPoints;
                // detailedLog += `  ${key.toUpperCase()} (${statValue}) * ${conversion[key]} = ${convertedPoints}\n`; // Removed
            }
        });
        
        // console.log(`[calculatePointsFromBBGMStats] Total calculated points: ${total}\n${detailedLog}`); // Reduced logging
        return total;
    }

    function exportModifiedBBGMPlayer() {
        console.log("[exportModifiedBBGMPlayer] Called.");
        if (!currentBBGMPlayerJson) {
            showMessage("No BBGM player data loaded to export.", 'info'); 
            console.warn("[exportModifiedBBGMPlayer] Export failed: No player data loaded.");
            return;
        }
        const playerName = currentBBGMPlayerJson.players[0].firstName + "_" + currentBBGMPlayerJson.players[0].lastName || "BBGM_Player";
        const blob = new Blob([JSON.stringify(currentBBGMPlayerJson, null, 2)], { type: "application/json" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `${playerName}_modified.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        showMessage("Modified player JSON exported successfully!", 'success');
        console.log(`[exportModifiedBBGMPlayer] Modified player JSON exported as ${link.download}`);
    }

    // New function to update the dedicated current ratings display panel
    function updateBBGMCurrentRatingsDisplayPanel() {
        const elements = getAppElements('bbgm');
        const displayPanel = elements.currentRatingsDisplay;
        if (!displayPanel) {
            console.error("BBGM current ratings display panel not found.");
            return;
        }

        if (!currentBBGMPlayerJson || !currentBBGMPlayerJson.players || !currentBBGMPlayerJson.players[0].ratings || !currentBBGMSeasonRatings) {
            displayPanel.innerHTML = '<p>No player loaded.</p>';
            return;
        }

        const player = currentBBGMPlayerJson.players[0];
        const ratings = currentBBGMSeasonRatings; 

        let content = '';
        // Add OVR, POS, POT at the top
        content += `<div style="font-weight: bold; margin-bottom: 10px;">`;
        content += `<div style="display: flex; justify-content: space-between;"><span>Overall:</span> <span>${ratings.ovr || 'N/A'}</span></div>`;
        content += `<div style="display: flex; justify-content: space-between;"><span>Position:</span> <span>${ratings.pos || 'N/A'}</span></div>`;
        content += `<div style="display: flex; justify-content: space-between;"><span>Potential:</span> <span>${ratings.pot || 'N/A'}</span></div>`;
        content += `<div style="display: flex; justify-content: space-between;"><span>Age:</span> <span>${player.age || 'N/A'}</span></div>`; // Display age
        content += `</div>`;

        // Ensure ratings is an object before proceeding
        if (typeof ratings === 'object' && ratings !== null) {
            // Group attributes by category
            const categorizedRatings = {};
            appData.bbgm.upgradeCategories.forEach(category => {
                categorizedRatings[category.label] = [];
                category.attributes.forEach(attrKey => {
                    // Exclude ovr, pos, pot, fuzz, hgt from the main list
                    // These are already displayed at the top, so exclude them from this detailed list
                    if (ratings.hasOwnProperty(attrKey) && !['ovr', 'pos', 'pot', 'fuzz', 'hgt'].includes(attrKey)) {
                        categorizedRatings[category.label].push({
                            key: attrKey,
                            value: ratings[attrKey],
                            label: appData.bbgm.attributeLabels[attrKey] || attrKey.toUpperCase()
                        });
                    }
                });
                // Sort attributes within each category alphabetically by label
                categorizedRatings[category.label].sort((a, b) => a.label.localeCompare(b.label));
            });

            // Render categorized ratings
            for (const categoryLabel in categorizedRatings) {
                if (categorizedRatings[categoryLabel].length > 0) {
                    content += `<h4 style="color: var(--accent); margin-top: 15px; margin-bottom: 5px;">${categoryLabel}</h4>`;
                    categorizedRatings[categoryLabel].forEach(item => {
                        const displayValue = typeof item.value === 'object' && item.value !== null ? JSON.stringify(item.value) : item.value;
                        content += `<div style="display: flex; justify-content: space-between; margin-bottom: 3px;"><span>${item.label}:</span> <span>${displayValue}</span></div>`;
                    });
                }
            }
        } else {
            content += `<p>Error: Ratings data is not in expected format.</p><p>Raw: ${JSON.stringify(ratings)}</p>`;
        }
        displayPanel.innerHTML = content;
    }

    // New function to update the Season Statistics panel
    function updateBBGMSeasonStatsPanel() {
        const elements = getAppElements('bbgm');
        const statsContentDisplay = elements.statsContentDisplay;
        const selectedSeason = parseInt(elements.seasonSelect.value);

        // Update button active states
        elements.showRegularSeasonStatsBtn.classList.remove('active');
        elements.showPlayoffStatsBtn.classList.remove('active');
        if (currentStatsView === 'regularSeason') {
            elements.showRegularSeasonStatsBtn.classList.add('active');
        } else {
            elements.showPlayoffStatsBtn.classList.add('active');
        }


        if (!currentBBGMPlayerJson || !currentBBGMPlayerJson.players || !currentBBGMPlayerJson.players[0].stats || isNaN(selectedSeason)) {
            statsContentDisplay.innerHTML = '<p>No stats available.</p>';
            return;
        }

        const playerStats = currentBBGMPlayerJson.players[0].stats;
        const seasonStats = playerStats.filter(s => s.season === selectedSeason);
        const regularSeasonStats = seasonStats.find(s => !s.playoffs);
        const playoffStats = seasonStats.find(s => s.playoffs);

        const formatStat = (label, value) => `<div style="display: flex; justify-content: space-between; margin-bottom: 3px;"><span>${label}:</span> <span>${value !== undefined ? value : 'N/A'}</span></div>`;

        let content = '';
        let statsToDisplay = null;

        if (currentStatsView === 'regularSeason') {
            statsToDisplay = regularSeasonStats;
        } else { // playoffs
            statsToDisplay = playoffStats;
        }

        if (statsToDisplay) {
            content += formatStat('Games Played', statsToDisplay.gp);
            content += formatStat('Minutes', statsToDisplay.min);
            content += formatStat('Points', (statsToDisplay.fg || 0) + (statsToDisplay.ft || 0) + (statsToDisplay.tp || 0)); // Assuming points are sum of FGs, FTs, 3PTs
            content += formatStat('Rebounds', statsToDisplay.reb);
            content += formatStat('Assists', statsToDisplay.ast);
            content += formatStat('Steals', statsToDisplay.stl);
            content += formatStat('Blocks', statsToDisplay.blk);
            content += formatStat('Turnovers', statsToDisplay.tov);
            content += formatStat('Personal Fouls', statsToDisplay.pf);
            content += formatStat('+/- Score', statsToDisplay.pm);
            content += formatStat('FG Made', statsToDisplay.fg);
            content += formatStat('3PT Made', statsToDisplay.tp);
            content += formatStat('FT Made', statsToDisplay.ft);

            // Add shooting percentages if available (fgp, tpp, ftp)
            if (statsToDisplay.fga !== undefined && statsToDisplay.fga > 0) {
                const fgp = ((statsToDisplay.fg / statsToDisplay.fga) * 100).toFixed(1);
                content += formatStat('FG%', `${fgp}%`);
            }
            if (statsToDisplay.tpa !== undefined && statsToDisplay.tpa > 0) {
                const tpp = ((statsToDisplay.tp / statsToDisplay.tpa) * 100).toFixed(1);
                content += formatStat('3PT%', `${tpp}%`);
            }
            if (statsToDisplay.fta !== undefined && statsToDisplay.fta > 0) {
                const ftp = ((statsToDisplay.ft / statsToDisplay.fta) * 100).toFixed(1);
                content += formatStat('FT%', `${ftp}%`);
            }

        } else {
            content += '<p>No stats available for this season.</p>';
        }
        statsContentDisplay.innerHTML = content;
    }


    async function generateScoutingReport() {
        console.log("[generateScoutingReport] Called.");
        if (!currentBBGMPlayerJson) {
            showMessage("Please import a BBGM player first to generate a scouting report.", 'info');
            console.warn("[generateScoutingReport] Scouting report failed: No player data loaded.");
            return;
        }
        const player = currentBBGMPlayerJson.players[0];
        const playerName = `${player.firstName || ''} ${player.lastName || ''}`.trim() || "Unnamed Player";
        const playerAge = player.age || "N/A";
        
        // Use currentBBGMSeasonRatings for the report
        const currentRatings = currentBBGMSeasonRatings;
        if (!currentRatings) {
            showMessage("No ratings available for the selected season to generate a report.", 'info');
            return;
        }
        const playerPos = currentRatings.pos || 'N/A';
        const playerOvr = currentRatings.ovr || 'N/A';


        const prompt = `Generate a basketball scouting report for a player with the following attributes:
Name: ${playerName}
Age: ${playerAge}
Overall Rating (OVR): ${playerOvr}
Position: ${playerPos}
Strength (stre): ${currentRatings.stre || 'N/A'}
Speed (spd): ${currentRatings.spd || 'N/A'}
Jumping (jmp): ${currentRatings.jmp || 'N/A'}
Endurance (endu): ${currentRatings.endu || 'N/A'}
Inside Scoring (ins): ${currentRatings.ins || 'N/A'}
Dunking (dnk): ${currentRatings.dnk || 'N/A'}
Free Throw (ft): ${currentRatings.ft || 'N/A'}
Field Goal (fg): ${currentRatings.fg || 'N/A'}
Three Point (tp): ${currentRatings.tp || 'N/A'}
Offensive IQ (oiq): ${currentRatings.oiq || 'N/A'}
Defensive IQ (diq): ${currentRatings.diq || 'N/A'}
Dribbling (drb): ${currentRatings.drb || 'N/A'}
Passing (pss): ${currentRatings.pss || 'N/A'}
Rebounding (reb): ${currentRatings.reb || 'N/A'}

The report should include:
1.  **Strengths:** What are their key skills and what do they excel at?
2.  **Weaknesses:** What areas need improvement?
3.  **Potential Role:** What kind of player can they become (e.g., scoring guard, defensive anchor, stretch four, all-around)?
4.  **Overall Assessment:** A brief summary of their game.

Keep it concise, professional, and use basketball terminology. Do not include any introductory or concluding phrases like 'Here is a scouting report' or 'In conclusion'.`;
        
        showMessage('<div class="spinner"></div><p>Generating report...</p>', 'info');
        console.log("[generateScoutingReport] Sending prompt to Gemini API.");

        try {
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = ""; // Canvas will automatically provide the API key
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            console.log("[generateScoutingReport] Gemini API response received:", result);
            
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                const reportText = result.candidates[0].content.parts[0].text.replace(/\n/g, '<br>');
                showMessage(`<div style="text-align: left;">${reportText}</div>`, 'info');
                console.log("[generateScoutingReport] Scouting report displayed successfully.");
            } else {
                throw new Error("Invalid response structure from Gemini API.");
            }
        } catch (error) {
            showMessage(`<p>Error generating report. Please check your network connection or try again later.</p>`, 'danger');
            console.error("[generateScoutingReport] Error calling Gemini API:", error);
        } finally {
            // No modal buttons to hide/show
        }
    }

    // BBGM OVR Calculation function (provided by user)
    function calculateOVR(ratings) {
        // Ensure all ratings are numbers, default to 0 if undefined or null
        const getRating = (attr) => ratings[attr] !== undefined && ratings[attr] !== null ? ratings[attr] : 0;

        const r =
            0.159 * (getRating('hgt') - 47.5) +
            0.0777 * (getRating('stre') - 50.2) +
            0.123 * (getRating('spd') - 50.8) +
            0.051 * (getRating('jmp') - 48.7) +
            0.0632 * (getRating('endu') - 39.9) +
            0.0126 * (getRating('ins') - 42.4) +
            0.0286 * (getRating('dnk') - 49.5) +
            0.0202 * (getRating('ft') - 47.0) +
            0.0726 * (getRating('tp') - 47.1) +
            0.133 * (getRating('oiq') - 46.8) +
            0.159 * (getRating('diq') - 46.7) +
            0.059 * (getRating('drb') - 54.8) +
            0.062 * (getRating('pss') - 51.3) +
            0.01 * (getRating('fg') - 47.0) +
            0.01 * (getRating('reb') - 51.4) +
            48.5;

        let fudgeFactor = 0;
        if (r >= 68) {
            fudgeFactor = 8;
        } else if (r >= 50) {
            fudgeFactor = 4 + (r - 50) * (4 / 18);
        } else if (r >= 42) {
            fudgeFactor = -5 + (r - 42) * (9 / 8);
        } else if (r >= 31) {
            fudgeFactor = -5 - (42 - r) * (5 / 11);
        } else {
            fudgeFactor = -10;
        }

        const val = Math.round(r + fudgeFactor);

        if (val > 100) {
            return 100;
        }
        if (val < 0) {
            return 0;
        }

        return val;
    }

    // Function to calculate potential
    function calculatePotential(ovr, age) {
        // Base potential is higher for younger players
        let potential = ovr + (23 - age) * 1.5; // Adjusted age influence for 17-23 range

        // Lower OVR players have more room to grow
        potential += Math.max(0, 70 - ovr) * 0.5; // Adjusted boost for lower OVR

        // Apply a nerf based on age for older players
        if (age >= 25) { // Start nerfing potential from age 25
            potential -= (age - 24) * 0.8; // More aggressive nerf as they get older
        }
        
        // Add a small random factor
        potential += (Math.random() - 0.5) * 5; // +/- 2.5

        return Math.min(100, Math.max(0, Math.round(potential)));
    }

    // Function to generate a random BBGM player
    function generateRandomBBGMPlayer() {
        console.log("[generateRandomBBGMPlayer] Generating random player.");

        const ovrChances = [
            { range: [0, 29], chance: 7.141 }, // <30 ovr
            { range: [30, 39], chance: 54.921 }, // <40 ovr
            { range: [40, 49], chance: 31.924 }, // <50 ovr
            { range: [50, 59], chance: 4.024 },  // <60 ovr
            { range: [60, 69], chance: 0.99 },   // <70 ovr
            { range: [70, 79], chance: 0.63 },   // <80 ovr
            { range: [80, 100], chance: 0.37 }   // 90+ ovr (adjusted to 80-100 for practical generation)
        ];

        let targetOvr = 0;
        let cumulativeChance = 0;
        const randomRoll = Math.random() * 100;

        for (const tier of ovrChances) {
            cumulativeChance += tier.chance;
            if (randomRoll <= cumulativeChance) {
                targetOvr = Math.floor(Math.random() * (tier.range[1] - tier.range[0] + 1)) + tier.range[0];
                break;
            }
        }
        if (targetOvr === 0) { // Fallback if no tier was hit (shouldn't happen with correct probabilities)
            targetOvr = Math.floor(Math.random() * 100);
        }
        console.log(`[generateRandomBBGMPlayer] Target OVR selected: ${targetOvr}`);

        const positions = ["PG", "SG", "SF", "PF", "C"];
        const randomPos = positions[Math.floor(Math.random() * positions.length)];
        const randomAge = Math.floor(Math.random() * (23 - 17 + 1)) + 17; // Age between 17 and 23

        // Base ratings (average around 50)
        let generatedRatings = {
            hgt: 60, stre: 50, spd: 50, jmp: 50, endu: 50,
            ins: 50, dnk: 50, ft: 50, fg: 50, tp: 50,
            oiq: 50, diq: 50, drb: 50, pss: 50, reb: 50,
        };

        // Positional biases
        const positionalBias = {
            "PG": { drb: 15, pss: 15, spd: 10, oiq: 10, ins: -5, reb: -5, stre: -5 },
            "SG": { tp: 15, fg: 10, drb: 5, spd: 5, diq: 5, reb: -5, stre: -5 },
            "SF": { fg: 10, dnk: 5, reb: 5, diq: 5, oiq: 5, tp: 5, ins: 5 },
            "PF": { reb: 15, ins: 10, stre: 10, blk: 5, dnk: 5, tp: -5, drb: -5 },
            "C": { ins: 15, reb: 15, stre: 10, blk: 10, dnk: 5, spd: -10, pss: -5, drb: -5, tp: -5 }
        };

        // Apply positional bias
        for (const attr in positionalBias[randomPos]) {
            generatedRatings[attr] = Math.max(0, Math.min(100, generatedRatings[attr] + positionalBias[randomPos][attr]));
        }

        // Add a small random spread to make attributes slightly different
        for (const attr in generatedRatings) {
            if (attr !== 'hgt') { // Height is more fixed
                generatedRatings[attr] = Math.max(0, Math.min(100, generatedRatings[attr] + (Math.floor(Math.random() * 11) - 5))); // +/- 5
            }
        }

        // Iteratively adjust attributes to get closer to target OVR
        let currentOvr = calculateOVR(generatedRatings);
        let iterations = 0;
        const maxIterations = 1000; // Increased iterations for better OVR matching
        const adjustmentStep = 1; // How much to adjust attributes by

        while (currentOvr !== targetOvr && iterations < maxIterations) {
            const diff = targetOvr - currentOvr;
            const attributesToAdjust = Object.keys(generatedRatings).filter(attr => !['hgt'].includes(attr)); 

            if (attributesToAdjust.length === 0) break; 

            // Prioritize adjusting attributes relevant to the target OVR direction
            // If OVR too low, increase attributes. If OVR too high, decrease.
            const sortedAttributes = attributesToAdjust.sort((a, b) => {
                const weightA = calculateOVR({ ...generatedRatings, [a]: generatedRatings[a] + (diff > 0 ? adjustmentStep : -adjustmentStep) }) - currentOvr;
                const weightB = calculateOVR({ ...generatedRatings, [b]: generatedRatings[b] + (diff > 0 ? adjustmentStep : -adjustmentStep) }) - currentOvr;
                return Math.abs(diff - weightA) - Math.abs(diff - weightB); // Pick attribute that gets closer to target OVR
            });

            const randomAttr = sortedAttributes[0]; // Pick the most impactful attribute for adjustment

            if (diff > 0) { // Need to increase OVR
                if (generatedRatings[randomAttr] < 100) {
                    generatedRatings[randomAttr] = Math.min(100, generatedRatings[randomAttr] + adjustmentStep);
                }
            } else { // Need to decrease OVR
                if (generatedRatings[randomAttr] > 0) {
                    generatedRatings[randomAttr] = Math.max(0, generatedRatings[randomAttr] - adjustmentStep);
                }
            }
            currentOvr = calculateOVR(generatedRatings);
            iterations++;
        }
        console.log(`[generateRandomBBGMPlayer] Final OVR: ${currentOvr} (Target: ${targetOvr}) after ${iterations} iterations.`);

        // Ensure all ratings are within 0-100 and are integers
        for (const key in generatedRatings) {
            generatedRatings[key] = Math.min(100, Math.max(0, Math.round(generatedRatings[key])));
        }

        const playerPot = calculatePotential(currentOvr, randomAge);

        const firstNames = ["James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph", "Charles", "Thomas", "Christopher", "Daniel", "Paul", "Mark", "Donald", "George", "Kenneth", "Steven", "Edward", "Brian"];
        const lastNames = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis", "Rodriguez", "Martinez", "Hernandez", "Lopez"];
        // Removed countries and weights as they are no longer displayed

        const randomFirstName = firstNames[Math.floor(Math.random() * firstNames.length)];
        const randomLastName = lastNames[Math.floor(Math.random() * lastNames.length)];

        const newPlayer = {
            pid: `random_player_${Date.now()}`,
            firstName: randomFirstName,
            lastName: randomLastName,
            age: randomAge,
            pos: randomPos,
            ovr: currentOvr,
            pot: playerPot,
            ratings: [{
                season: new Date().getFullYear(), // Current year
                ...generatedRatings,
                ovr: currentOvr, // Ensure OVR in ratings matches calculated
                pos: randomPos,
                pot: playerPot,
            }],
            stats: [] // No stats for random players
        };

        // Set the generated player as the current player
        currentBBGMPlayerJson = { players: [newPlayer] };
        currentBBGMPlayerId = newPlayer.pid;
        currentBBGMSeasonRatings = newPlayer.ratings[0]; // Set current season ratings to the generated ones

        // Initialize bbgmAttributeTargets with the new player's current ratings
        bbgmAttributeTargets = {};
        for (const attrKey in currentBBGMSeasonRatings) {
            if (appData.bbgm.attributeLabels.hasOwnProperty(attrKey)) {
                bbgmAttributeTargets[attrKey] = currentBBGMSeasonRatings[attrKey] || 0;
            }
        }

        // Do NOT set initial points based on OVR here. User will add manually.
        // const elements = getAppElements('bbgm');
        // const basePointsLowOvr = 200000; // More points for very low OVR
        // const pointsDecreasePerOvr = 2500; // Decrease points as OVR increases
        // const initialPoints = Math.max(0, basePointsLowOvr - (newPlayer.ovr * pointsDecreasePerOvr)); 
        // elements.manualTotalPoints.value = initialPoints;
        // updatePointsBankDisplay('bbgm');

        // Update all relevant UI elements after generating a new player
        populateBBGMSeasonSelect(); // Re-populate season select (will select current year)
        updateBBGMPlayerInfoDisplay(); // Update player info panel
        updateBBGMCurrentRatingsUI(); // Update current ratings panel and upgrade inputs
        calculateAllUpgrades('bbgm'); // Recalculate upgrade costs based on new player
        updateBBGMSeasonStatsPanel(); // Update season stats panel (will be empty for new player)

        showMessage(`Generated new player: ${newPlayer.firstName} ${newPlayer.lastName} (OVR: ${newPlayer.ovr}, POT: ${newPlayer.pot}, Age: ${newPlayer.age}, Pos: ${newPlayer.pos}).`, 'success');
    }


    // --- INITIALIZATION ---
    window.onload = function() {
      console.log("--- Application Initializing ---");
      const bg = document.getElementById('space-bg');
      if (bg) {
        for (let i = 0; i < 100; i++) {
          const p = document.createElement('div');
          p.className = 'particle';
          p.style.left = `${Math.random() * 100}vw`;
          p.style.top = `${Math.random() * -100}vh`;
          p.style.animationDuration = `${5 + Math.random() * 10}s`;
          bg.appendChild(p);
        }
        console.log("Background particles generated.");
      } else {
        console.warn("Background element #space-bg not found.");
      }

      const isLightMode = loadFromLocal('darkMode');
      if (isLightMode) {
        document.body.classList.add('light-mode');
        console.log("Light mode enabled from local storage.");
      } else {
        console.log("Dark mode enabled (default or from local storage).");
      }

      const showTutorialOnStartup = loadFromLocal('showTutorialOnStartup');
      const tutorialCheckbox = document.getElementById('showTutorialOnStartup');
      if (tutorialCheckbox) {
          tutorialCheckbox.checked = showTutorialOnStartup === true;
          console.log(`Tutorial checkbox initialized to: ${tutorialCheckbox.checked}`);
      } else {
          console.warn("Tutorial checkbox #showTutorialOnStartup not found.");
      }
      
      // Removed automatic setting of forceNewPlayerImport to true on startup.
      // This is now handled within showApp('bbgm') based on whether a player is loaded.

      attachEventListeners();
      console.log("All event listeners attached.");

      const activeApp = loadFromLocal('activeApp');
      if (showTutorialOnStartup === true) {
        showApp('manual'); // Show manual on startup if enabled
        saveToLocal('showTutorialOnStartup', false); // Turn off for next time
        console.log("Tutorial shown on startup, setting flag to false for next time.");
      } else if (activeApp) {
        showApp(activeApp);
        console.log(`Restoring active app: ${activeApp}`);
      } else {
        document.getElementById('mainMenu')?.classList.add('active');
        console.log("No active app found, showing main menu.");
      }
      console.log("--- Application Initializing ---");
    };
  </script>
</body>
</html>
